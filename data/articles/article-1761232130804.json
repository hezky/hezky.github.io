{
  "title": "Service Worker",
  "description": "Kompletní průvodce offline webovými aplikacemi",
  "markdown": "# Service Worker: Kompletní průvodce offline webovými aplikacemi\n\n## Úvod\n\nService Worker je moderní technologie, která revolucionalizuje způsob, jakým webové aplikace fungují. Představuje most mezi klasickými webovými stránkami a nativními mobilními aplikacemi. V tomto článku se podrobně podíváme na implementaci vzdělávací aplikace demonstrující Service Worker technologii s použitím Reactu, čistého JavaScriptu a BEM metodiky pro CSS.\n\nWebové aplikace se tradičně potýkají s jedním zásadním problémem – závislostí na internetovém připojení. Jakmile ztratíte spojení se sítí, aplikace přestane fungovat. Service Worker tuto situaci radikálně mění. Umožňuje webovým aplikacím fungovat offline, cachovat zdroje, zachycovat síťové požadavky a poskytovat uživatelům plynulou zkušenost bez ohledu na stav připojení.\n\nV rámci tohoto projektu jsme vytvořili komplexní vzdělávací aplikaci, která nejen demonstruje Service Worker technologii v praxi, ale také slouží jako interaktivní tutoriál. Uživatelé se mohou naučit klíčové koncepty, prozkoumat životní cyklus Service Workeru a vyzkoušet si různé caching strategie.\n\n## Co je Service Worker?\n\nService Worker je JavaScript soubor, který běží na pozadí v prohlížeči, odděleně od webové stránky. Funguje jako proxy server mezi webovou aplikací, prohlížečem a sítí (pokud je dostupná). Tato architektura poskytuje několik klíčových výhod:\n\n### Hlavní charakteristiky\n\n**Oddělené vlákno**: Service Worker běží ve vlastním JavaScript vláknu, odděleném od hlavního vlákna webové stránky. To znamená, že nemá přímý přístup k DOM a nemůže blokovat hlavní vlákno aplikace. Veškerá komunikace mezi Service Workerem a stránkou probíhá prostřednictvím postMessage API.\n\n**Event-driven architektura**: Service Worker pracuje na principu událostí. Když se něco stane (instalace, aktivace, síťový požadavek), Service Worker na to reaguje pomocí event listenerů. Tato architektura je velmi efektivní, protože Service Worker může být aktivní pouze když je potřeba, což šetří systémové prostředky.\n\n**Požadavek na HTTPS**: Service Worker vyžaduje HTTPS připojení (s výjimkou localhost pro vývoj). Toto bezpečnostní opatření je kritické, protože Service Worker má velmi mocné schopnosti – může zachycovat síťové požadavky, upravovat je a poskytovat vlastní odpovědi. Bez HTTPS by útočník mohl nahradit Service Worker škodlivým kódem.\n\n**Asynchronní API**: Service Worker používá výhradně asynchronní API založené na Promises. Synchronní API jako localStorage nebo XHR synchronní volání nejsou v Service Workeru dostupné. Místo toho používáme Cache API a Fetch API, které jsou moderní a výkonné.\n\n**Životní cyklus**: Service Worker má složitý životní cyklus, který zajišťuje, že aktualizace probíhají hladce a uživatelé nevidí polofunkční stav. Detailně si životní cyklus rozebereme v následující sekci.\n\n### Proč Service Worker potřebujeme?\n\n**Offline funkčnost**: Hlavním přínosem je schopnost aplikace pracovat offline. Service Worker může cachovat všechny potřebné soubory a poskytovat je, i když není k dispozici síťové připojení.\n\n**Výkonnostní optimalizace**: Cachování zdrojů znamená, že při opakovaném načtení stránky nemusíme stahovat stejné soubory znovu. Aplikace se načte okamžitě z cache, což výrazně zrychluje načítání.\n\n**Background sync**: Service Worker umožňuje synchronizaci dat na pozadí. Pokud uživatel provede akci offline, Service Worker ji může zařadit do fronty a provést, jakmile se obnoví připojení.\n\n**Push notifikace**: Service Worker je základ pro push notifikace na webu. Může přijímat zprávy ze serveru a zobrazovat notifikace, i když uživatel nemá aplikaci otevřenou.\n\n## Životní cyklus Service Workeru\n\nPochopení životního cyklu Service Workeru je naprosto klíčové pro správnou implementaci. Životní cyklus se skládá z několika fází, přičemž každá má svůj účel.\n\n### Fáze 1: Registrace\n\nVše začíná registrací Service Workeru. V naší aplikaci se registrace provádí v `src/index.js`:\n\n```javascript\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js')\n      .then(registration => {\n        console.log('✅ Service Worker registered:', registration.scope);\n      })\n      .catch(error => {\n        console.error('❌ Service Worker registration failed:', error);\n      });\n  });\n}\n```\n\n**Proč čekáme na load event?** Registrace Service Workeru může být náročná operace. Pokud bychom ji provedli hned při načítání stránky, mohla by konkurovat stahování důležitých zdrojů a zpomalit první načtení. Čekáním na load event zajistíme, že aplikace je plně načtena a teprve poté registrujeme Service Worker.\n\n**Scope**: Parametr `scope` určuje, které URL může Service Worker kontrolovat. Ve výchozím nastavení je scope určen lokací service worker souboru. Pokud je `service-worker.js` v kořenovém adresáři, bude kontrolovat celou doménu.\n\n**Podmíněná registrace**: Před registrací kontrolujeme, zda prohlížeč Service Worker podporuje pomocí `'serviceWorker' in navigator`. Starší prohlížeče tuto vlastnost nemají, a aplikace bude fungovat i bez Service Workeru (pouze bez offline schopností).\n\n### Fáze 2: Instalace (Install Event)\n\nKdyž prohlížeč detekuje nový Service Worker soubor (nebo aktualizovanou verzi), spustí install event. Toto je ideální místo pro cachování statických zdrojů:\n\n```javascript\nconst CACHE_NAME = 'sw-edu-app-v1';\nconst STATIC_ASSETS = ['/', '/index.html', '/manifest.json'];\n\nself.addEventListener('install', (event) => {\n  console.log('[SW] Install event');\n\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(STATIC_ASSETS))\n      .then(() => self.skipWaiting())\n  );\n});\n```\n\n**event.waitUntil()**: Tato metoda je kritická. Říká prohlížeči: \"Počkej s dokončením instalace, dokud se neprovede Promise uvnitř.\" Bez waitUntil by prohlížeč mohl ukončit Service Worker dříve, než se stihnou cachovat všechny soubory.\n\n**caches.open()**: Cache API poskytuje úložiště pro HTTP odpovědi. Můžeme mít více cache s různými názvy. Otevřeme (nebo vytvoříme) cache s daným jménem.\n\n**cache.addAll()**: Tato metoda stáhne všechny URL v poli a uloží je do cache. Pokud jakýkoli soubor selže, celá operace selže. To je záměrné chování – chceme mít jistotu, že máme všechny důležité soubory cachované.\n\n**self.skipWaiting()**: Normálně nový Service Worker čeká ve stavu \"waiting\", dokud všechny stránky používající starý Service Worker nejsou zavřeny. skipWaiting() přeskočí toto čekání a aktivuje nový Service Worker okamžitě. To je užitečné pro rychlé nasazení aktualizací, ale může způsobit problémy, pokud máme několik verzí aplikace běžících současně.\n\n**Verzování cache**: Všimněte si verze v názvu cache (`v1`). Když aktualizujeme aplikaci, zvýšíme verzi. Starý Service Worker bude používat starou cache, nový Service Worker vytvoří novou cache. V activate eventu pak smažeme staré cache.\n\n### Fáze 3: Aktivace (Activate Event)\n\nPo úspěšné instalaci následuje aktivace. Activate event je ideální místo pro čištění starých cache:\n\n```javascript\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activate event');\n\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.map(cacheName => {\n            if (cacheName !== CACHE_NAME && cacheName !== RUNTIME_CACHE) {\n              console.log('[SW] Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => self.clients.claim())\n  );\n});\n```\n\n**caches.keys()**: Vrátí pole se jmény všech cache v aplikaci.\n\n**Čištění starých cache**: Procházíme všechny cache a mažeme ty, které neodpovídají aktuální verzi. To je důležité pro uvolnění místa a zajištění, že používáme aktuální soubory.\n\n**Promise.all()**: Čekáme na smazání všech starých cache. Promise.all() vezme pole promises a vrátí promise, která se splní, když se splní všechny promises v poli.\n\n**clients.claim()**: Normálně Service Worker začne kontrolovat stránky až při jejich dalším načtení. claim() řekne Service Workeru: \"Převezmi kontrolu nad všemi existujícími stránkami hned.\" To je užitečné kombinaci s skipWaiting() pro okamžitou aktivaci nového Service Workeru.\n\n### Fáze 4: Fetch události\n\nPo aktivaci je Service Worker plně funkční a může zachycovat síťové požadavky pomocí fetch eventu:\n\n```javascript\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  if (!url.protocol.startsWith('http')) return;\n  if (url.origin !== self.location.origin) return;\n\n  if (request.destination === 'document') {\n    event.respondWith(networkFirstStrategy(request));\n  } else {\n    event.respondWith(cacheFirstStrategy(request));\n  }\n});\n```\n\n**Zachycení požadavků**: Každý HTTP(S) požadavek, který aplikace provede, projde fetch eventem Service Workeru. Můžeme se rozhodnout, jak na požadavek odpovíme.\n\n**event.respondWith()**: Tato metoda nám umožňuje poskytnout vlastní odpověď na požadavek. Můžeme vrátit cached odpověď, provést vlastní síťový požadavek, nebo vytvořit odpověď kompletně dynamicky.\n\n**Filtrování požadavků**: Není vhodné zachycovat všechny požadavky. Měli bychom ignorovat non-HTTP protokoly (chrome-extension://, atd.) a požadavky na jiné domény (kvůli CORS).\n\n**Rozhodování podle typu**: Používáme `request.destination` k určení typu zdroje. HTML dokumenty obvykle chceme mít aktuální (network-first), zatímco statické soubory jako CSS, JS nebo obrázky mohou použít cache-first strategii.\n\n## Caching strategie\n\nVolba správné caching strategie je klíčová pro výkon a uživatelskou zkušenost. Různé typy zdrojů mají různé požadavky.\n\n### Cache-First strategie\n\nCache-First je ideální pro statické soubory, které se mění zřídka:\n\n```javascript\nasync function cacheFirstStrategy(request) {\n  try {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log('[SW] Cache hit:', request.url);\n      return cachedResponse;\n    }\n\n    const networkResponse = await fetch(request);\n    if (networkResponse && networkResponse.status === 200) {\n      const cache = await caches.open(RUNTIME_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    return new Response('Offline - Resource not available', {\n      status: 503,\n      statusText: 'Service Unavailable'\n    });\n  }\n}\n```\n\n**Postup**:\n1. Nejprve se podíváme do cache pomocí `caches.match()`\n2. Pokud najdeme odpověď v cache, vrátíme ji okamžitě\n3. Pokud není v cache, stáhneme ze sítě\n4. Úspěšnou odpověď uložíme do runtime cache pro příští použití\n5. Pokud selže i síť, vrátíme fallback odpověď\n\n**Výhody**: Extrémně rychlé načítání z cache, funguje kompletně offline po první návštěvě.\n\n**Nevýhody**: Uživatel může vidět zastaralý obsah, pokud se soubor změnil.\n\n**Vhodné pro**: CSS, JavaScript bundle, fonty, obrázky, ikony.\n\n**clone() metoda**: HTTP odpověď může být přečtena pouze jednou. Když chceme odpověď vrátit klientovi a zároveň uložit do cache, musíme ji klonovat.\n\n### Network-First strategie\n\nNetwork-First je vhodná pro obsah, který se často mění:\n\n```javascript\nasync function networkFirstStrategy(request) {\n  try {\n    const networkResponse = await fetch(request);\n    if (networkResponse && networkResponse.status === 200) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log('[SW] Serving from cache (offline):', request.url);\n      return cachedResponse;\n    }\n    return new Response('Offline - Page not cached', {\n      status: 503\n    });\n  }\n}\n```\n\n**Postup**:\n1. Nejprve zkusíme stáhnout ze sítě\n2. Úspěšnou odpověď cachujeme\n3. Pokud síť selže, zkusíme cache\n4. Pokud není ani v cache, vrátíme error\n\n**Výhody**: Uživatel vidí vždy aktuální obsah (pokud je online), graceful degradation při offline.\n\n**Nevýhody**: Pomalejší načítání, když je síť dostupná (ale pomalá).\n\n**Vhodné pro**: HTML stránky, API požadavky, často se měnící obsah.\n\n### Stale-While-Revalidate\n\nTato strategie kombinuje rychlost cache s aktuálností sítě:\n\n```javascript\nasync function staleWhileRevalidate(request) {\n  const cache = await caches.open(CACHE_NAME);\n  const cachedResponse = await cache.match(request);\n\n  const fetchPromise = fetch(request).then(networkResponse => {\n    cache.put(request, networkResponse.clone());\n    return networkResponse;\n  });\n\n  return cachedResponse || fetchPromise;\n}\n```\n\n**Postup**:\n1. Načteme z cache (pokud existuje) a vrátíme okamžitě\n2. Současně spustíme síťový požadavek na pozadí\n3. Když síťová odpověď dorazí, aktualizujeme cache\n4. Příští požadavek dostane aktualizovanou verzi\n\n**Výhody**: Okamžitá odpověď z cache + automatická aktualizace na pozadí.\n\n**Nevýhody**: Uživatel může vidět zastaralý obsah na první zobrazení.\n\n**Vhodné pro**: Avatary, ikony profilů, feed obsahy.\n\n### Cache-Only a Network-Only\n\n**Cache-Only**: Odpověď pouze z cache, síť se nepoužívá. Vhodné pro kompletně statické aplikace nebo předcachované zdroje.\n\n**Network-Only**: Vždy ze sítě, cache se nepoužívá. Vhodné pro kritické operace nebo data, která nesmí být cachována (platební brány, osobní data).\n\n## Technická implementace aplikace\n\nNaše aplikace je postavena s důrazem na jednoduchost, výkon a vzdělávací hodnotu.\n\n### Architektura projektu\n\n```\nlab_serviceWorker/\n├── src/\n│   ├── components/         # React komponenty s BEM\n│   ├── styles/            # Globální CSS\n│   ├── App.js             # Hlavní komponenta\n│   └── index.js           # Entry point + SW registrace\n├── public/\n│   ├── service-worker.js  # Service Worker logika\n│   ├── manifest.json      # PWA manifest\n│   └── index.html         # HTML šablona\n└── dist/                  # Build výstup\n```\n\n**Důvod struktury**: Komponenty jsou oddělené do vlastních složek s vlastními CSS soubory. To podporuje modularitu a usnadňuje údržbu.\n\n### React komponenty s BEM\n\nVšechny komponenty následují BEM (Block Element Modifier) metodiku:\n\n**Block**: Samostatná entita, která má smysl sama o sobě (`.header`, `.hero`, `.footer`).\n\n**Element**: Část bloku, která nemá samostatný význam (`.header__logo`, `.header__nav`).\n\n**Modifier**: Varianta bloku nebo elementu (`.button--primary`, `.card--highlighted`).\n\nPříklad z Header komponenty:\n\n```jsx\n// src/components/Header/Header.js\nfunction Header() {\n  return (\n    <header className=\"header\">\n      <div className=\"header__container\">\n        <div className=\"header__logo\">\n          <BookOpen className=\"header__logo-icon\" />\n          <span className=\"header__logo-text\">Service Worker Edu</span>\n        </div>\n        <nav className=\"header__nav\">\n          <a href=\"#concepts\" className=\"header__nav-link\">Koncepty</a>\n        </nav>\n      </div>\n    </header>\n  );\n}\n```\n\n**Výhody BEM**:\n- Jasná struktura CSS tříd\n- Žádné konflikty názvů\n- Snadná údržba a refactoring\n- Samopopisný kód\n\n### Online/Offline detekce\n\nAplikace detekuje změny připojení a aktualizuje UI:\n\n```javascript\nconst [isOnline, setIsOnline] = useState(navigator.onLine);\n\nuseEffect(() => {\n  const handleOnline = () => setIsOnline(true);\n  const handleOffline = () => setIsOnline(false);\n\n  window.addEventListener('online', handleOnline);\n  window.addEventListener('offline', handleOffline);\n\n  return () => {\n    window.removeEventListener('online', handleOnline);\n    window.removeEventListener('offline', handleOffline);\n  };\n}, []);\n```\n\n**navigator.onLine**: Indikuje, zda prohlížeč má aktivní připojení. Je třeba poznamenat, že `true` neznamená, že máme fungující internet – pouze že máme síťové připojení.\n\n**online/offline události**: Tyto události se spustí, když se změní stav připojení. Můžeme na ně reagovat a upravit UI.\n\n### Webpack konfigurace\n\nWebpack slouží k bundlování aplikace:\n\n```javascript\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js',\n    clean: true\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html'\n    }),\n    new CopyWebpackPlugin({\n      patterns: [\n        { from: 'public/service-worker.js', to: 'service-worker.js' },\n        { from: 'public/manifest.json', to: 'manifest.json' }\n      ]\n    })\n  ]\n};\n```\n\n**contenthash**: Přidává hash do názvu souboru na základě obsahu. Když se obsah změní, změní se i název, což vyřeší cache invalidation.\n\n**CopyWebpackPlugin**: Service Worker musí být v root adresáři, aby měl správný scope. Plugin kopíruje soubor bez bundlování.\n\n## Best Practices a doporučení\n\n### Verzování Service Workeru\n\nVždy používejte verzi v názvu cache:\n\n```javascript\nconst CACHE_NAME = 'app-v1';\nconst RUNTIME_CACHE = 'app-runtime-v1';\n```\n\nPři aktualizaci zvyšte verzi. Starý Service Worker bude používat starou cache, nový vytvoří novou.\n\n### Rozdělení cache\n\nOddělte statickou cache od runtime cache. Statická cache obsahuje předcachované soubory, runtime cache se plní dynamicky:\n\n```javascript\n// Statické soubory - cachují se při instalaci\nconst STATIC_ASSETS = ['/', '/index.html', '/manifest.json'];\n\n// Runtime cache - plní se během používání\n// CSS, JS, obrázky se přidávají do runtime cache automaticky\n```\n\n### Velikost cache\n\nMonitorujte velikost cache. Cache API má limity (obvykle několik GB, ale závisí na prohlížeči a dostupném místě):\n\n```javascript\nif ('storage' in navigator && 'estimate' in navigator.storage) {\n  navigator.storage.estimate().then(({ usage, quota }) => {\n    console.log(`Using ${usage} out of ${quota} bytes.`);\n  });\n}\n```\n\n### Testování offline\n\nVždy testujte offline funkcionalitu:\n\n1. Otevřete DevTools\n2. Jděte na Application tab → Service Workers\n3. Zaškrtněte \"Offline\"\n4. Reloadněte stránku\n\nAplikace by měla fungovat kompletně bez připojení.\n\n### Aktualizace Service Workeru\n\nKdyž změníte Service Worker soubor (byť o jeden byte), prohlížeč detekuje změnu a spustí instalaci nového Service Workeru. Uživatel ale může používat starou verzi, dokud nezavře všechny taby. Řešení:\n\n```javascript\n// V aplikaci\nnavigator.serviceWorker.addEventListener('controllerchange', () => {\n  window.location.reload();\n});\n\n// V Service Workeru\nself.addEventListener('message', (event) => {\n  if (event.data === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n```\n\n### Debug Service Workeru\n\nChrome DevTools poskytují výborné nástroje:\n\n1. **Application tab**: Zobrazuje registrované Service Workery, cache, manifest\n2. **Console**: Logy ze Service Workeru (i když stránka není otevřená)\n3. **Network tab**: Označuje požadavky obsloužené Service Workerem\n4. **Lighthouse**: Audit PWA kompatibility\n\n## Výkonnostní optimalizace\n\n### Precaching vs Runtime Caching\n\n**Precaching** (install event): Cachujte pouze nezbytné soubory pro zobrazení základní stránky. Přílišné precachování zpomalí instalaci.\n\n**Runtime caching** (fetch event): Ostatní soubory se cachují při prvním použití. To rozloží cachování v čase.\n\n### Strategické cachování\n\nRůzné typy souborů = různé strategie:\n\n- HTML: Network-First (chceme čerstvý obsah)\n- CSS/JS: Cache-First (mění se při novém build)\n- Obrázky: Cache-First (obvykle statické)\n- API data: Network-First nebo Stale-While-Revalidate\n\n### Komprimace\n\nCache API ukládá odpovědi tak, jak je dostane. Ujistěte se, že server posílá komprimovaný obsah (gzip, brotli).\n\n## Bezpečnost\n\n### HTTPS požadavek\n\nService Worker vyžaduje HTTPS (kromě localhost). Bez HTTPS by mohl útočník nahradit Service Worker a zachycovat všechna data.\n\n### Validace odpovědí\n\nPřed cachováním validujte odpovědi:\n\n```javascript\nif (response && response.status === 200 && response.type === 'basic') {\n  cache.put(request, response.clone());\n}\n```\n\n**response.type**: Může být 'basic' (same-origin), 'cors', 'opaque'. Opaque odpovědi (cross-origin bez CORS) nelze číst a měly by se cachovat opatrně.\n\n### Sensitive data\n\nNikdy necachujte citlivá data (hesla, tokeny, osobní informace) bez důkladného uvážení. Cache je přístupná přes DevTools.\n\n## Závěr\n\nService Worker je mocná technologie, která otevírá dveře offline webovým aplikacím. Implementace vyžaduje pečlivé plánování a pochopení životního cyklu, ale výsledek stojí za to – aplikace, která funguje vždy, bez ohledu na kvalitu připojení.\n\nNaše vzdělávací aplikace demonstruje všechny klíčové koncepty: registraci, instalaci, aktivaci, různé caching strategie, online/offline detekci a best practices. Používá moderní stack (React 18, Webpack 5, ES6+) a BEM metodiku pro udržitelný CSS.\n\nService Worker je základ Progressive Web Apps (PWA). S přidáním manifestu a dalších PWA funkcí může být naše aplikace instalovatelná na desktop i mobily, běžet na celé obrazovce a chovat se téměř identicky jako nativní aplikace.\n\nBudoucnost webu je v PWA a Service Worker je jejich srdce. Investice do učení této technologie se rozhodně vyplatí – aplikace budou rychlejší, spolehlivější a poskytnou lepší uživatelskou zkušenost.\n\n## Zdroje\n\n- **MDN Web Docs**: Komplexní dokumentace Service Worker API\n- **web.dev**: Google průvodce PWA a Service Worker best practices\n- **Chrome DevTools**: Nástroje pro debug a testování\n- **Workbox**: Knihovna od Google pro snadnější práci se Service Worker\n\nTato aplikace je open-source a slouží jako výukový materiál. Kód je důkladně okomentovaný a strukturovaný pro snadné pochopení. Doporučujeme prozkoumat zdrojový kód, experimentovat s různými strategiemi a adaptovat řešení pro vlastní projekty.\n",
  "tags": [
    "Javascript",
    "Service Worker"
  ],
  "category": "",
  "metadata": {
    "readingTime": "20 min"
  },
  "id": "article-1761232130804",
  "date": "2025-10-23",
  "filename": "articles/article-1761232130804.json",
  "title.en": "Service Worker",
  "description.en": "Complete Guide to Offline Web Applications",
  "tags.en": [
    "Javascript",
    "Service Worker"
  ],
  "category.en": null,
  "markdown.en": "# Service Worker: Complete Guide to Offline Web Applications\n\n## Introduction\n\nService Worker is a modern technology that revolutionizes how web applications work. It represents a bridge between classic web pages and native mobile applications. In this article, we'll take a detailed look at implementing an educational application demonstrating Service Worker technology using React, pure JavaScript, and BEM methodology for CSS.\n\nWeb applications traditionally struggle with one fundamental problem – dependency on internet connection. Once you lose network connectivity, the application stops working. Service Worker radically changes this situation. It enables web applications to work offline, cache resources, intercept network requests, and provide users with a seamless experience regardless of connection status.\n\nAs part of this project, we created a comprehensive educational application that not only demonstrates Service Worker technology in practice but also serves as an interactive tutorial. Users can learn key concepts, explore the Service Worker lifecycle, and try out different caching strategies.\n\n## What is Service Worker?\n\nService Worker is a JavaScript file that runs in the background in the browser, separate from the web page. It functions as a proxy server between the web application, browser, and network (when available). This architecture provides several key advantages:\n\n### Main Characteristics\n\n**Separate Thread**: Service Worker runs in its own JavaScript thread, separated from the main page thread. This means it doesn't have direct DOM access and can't block the application's main thread. All communication between Service Worker and the page happens through the postMessage API.\n\n**Event-Driven Architecture**: Service Worker works on an event-driven principle. When something happens (installation, activation, network request), Service Worker responds using event listeners. This architecture is very efficient because Service Worker can be active only when needed, saving system resources.\n\n**HTTPS Requirement**: Service Worker requires HTTPS connection (except localhost for development). This security measure is critical because Service Worker has very powerful capabilities – it can intercept network requests, modify them, and provide custom responses. Without HTTPS, an attacker could replace the Service Worker with malicious code.\n\n**Asynchronous API**: Service Worker uses exclusively asynchronous Promise-based APIs. Synchronous APIs like localStorage or synchronous XHR calls are not available in Service Worker. Instead, we use Cache API and Fetch API, which are modern and performant.\n\n**Lifecycle**: Service Worker has a complex lifecycle that ensures updates happen smoothly and users don't see half-functional states. We'll explore the lifecycle in detail in the next section.\n\n### Why Do We Need Service Worker?\n\n**Offline Functionality**: The main benefit is the ability of the application to work offline. Service Worker can cache all necessary files and provide them even when network connection is unavailable.\n\n**Performance Optimization**: Caching resources means that when reloading the page, we don't need to download the same files again. The application loads instantly from cache, significantly speeding up loading times.\n\n**Background Sync**: Service Worker enables background data synchronization. If a user performs an action offline, Service Worker can queue it and execute when connection is restored.\n\n**Push Notifications**: Service Worker is the foundation for web push notifications. It can receive messages from the server and display notifications even when the user doesn't have the application open.\n\n## Service Worker Lifecycle\n\nUnderstanding the Service Worker lifecycle is absolutely crucial for proper implementation. The lifecycle consists of several phases, each with its purpose.\n\n### Phase 1: Registration\n\nEverything starts with Service Worker registration. In our application, registration happens in `src/index.js`:\n\n```javascript\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js')\n      .then(registration => {\n        console.log('✅ Service Worker registered:', registration.scope);\n      })\n      .catch(error => {\n        console.error('❌ Service Worker registration failed:', error);\n      });\n  });\n}\n```\n\n**Why wait for load event?** Service Worker registration can be a demanding operation. If we performed it immediately during page load, it could compete with downloading important resources and slow down first load. By waiting for the load event, we ensure the application is fully loaded before registering the Service Worker.\n\n**Scope**: The `scope` parameter determines which URLs the Service Worker can control. By default, scope is determined by the service worker file location. If `service-worker.js` is in the root directory, it will control the entire domain.\n\n**Conditional Registration**: Before registration, we check if the browser supports Service Worker using `'serviceWorker' in navigator`. Older browsers don't have this property, and the application will work without Service Worker (just without offline capabilities).\n\n### Phase 2: Installation (Install Event)\n\nWhen the browser detects a new Service Worker file (or updated version), it triggers the install event. This is the ideal place to cache static resources:\n\n```javascript\nconst CACHE_NAME = 'sw-edu-app-v1';\nconst STATIC_ASSETS = ['/', '/index.html', '/manifest.json'];\n\nself.addEventListener('install', (event) => {\n  console.log('[SW] Install event');\n\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(STATIC_ASSETS))\n      .then(() => self.skipWaiting())\n  );\n});\n```\n\n**event.waitUntil()**: This method is critical. It tells the browser: \"Wait to complete installation until the Promise inside resolves.\" Without waitUntil, the browser could terminate the Service Worker before all files are cached.\n\n**caches.open()**: Cache API provides storage for HTTP responses. We can have multiple caches with different names. We open (or create) a cache with the given name.\n\n**cache.addAll()**: This method downloads all URLs in the array and stores them in cache. If any file fails, the entire operation fails. This is intentional behavior – we want certainty that we have all important files cached.\n\n**self.skipWaiting()**: Normally, a new Service Worker waits in \"waiting\" state until all pages using the old Service Worker are closed. skipWaiting() skips this wait and activates the new Service Worker immediately. This is useful for quick deployment of updates but can cause issues if we have multiple versions of the application running simultaneously.\n\n**Cache Versioning**: Notice the version in the cache name (`v1`). When we update the application, we increment the version. The old Service Worker will use the old cache, the new Service Worker creates a new cache. In the activate event, we then delete old caches.\n\n### Phase 3: Activation (Activate Event)\n\nAfter successful installation comes activation. The activate event is the ideal place for cleaning up old caches:\n\n```javascript\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activate event');\n\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.map(cacheName => {\n            if (cacheName !== CACHE_NAME && cacheName !== RUNTIME_CACHE) {\n              console.log('[SW] Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => self.clients.claim())\n  );\n});\n```\n\n**caches.keys()**: Returns an array with names of all caches in the application.\n\n**Cleaning Old Caches**: We iterate through all caches and delete those that don't match the current version. This is important for freeing up space and ensuring we use current files.\n\n**Promise.all()**: We wait for deletion of all old caches. Promise.all() takes an array of promises and returns a promise that resolves when all promises in the array resolve.\n\n**clients.claim()**: Normally, Service Worker starts controlling pages only on their next load. claim() tells the Service Worker: \"Take control of all existing pages immediately.\" This is useful in combination with skipWaiting() for immediate activation of new Service Worker.\n\n### Phase 4: Fetch Events\n\nAfter activation, Service Worker is fully functional and can intercept network requests using the fetch event:\n\n```javascript\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  if (!url.protocol.startsWith('http')) return;\n  if (url.origin !== self.location.origin) return;\n\n  if (request.destination === 'document') {\n    event.respondWith(networkFirstStrategy(request));\n  } else {\n    event.respondWith(cacheFirstStrategy(request));\n  }\n});\n```\n\n**Request Interception**: Every HTTP(S) request the application makes goes through Service Worker's fetch event. We can decide how to respond to the request.\n\n**event.respondWith()**: This method allows us to provide a custom response to the request. We can return a cached response, make our own network request, or create a response completely dynamically.\n\n**Request Filtering**: It's not appropriate to intercept all requests. We should ignore non-HTTP protocols (chrome-extension://, etc.) and requests to other domains (due to CORS).\n\n**Decision by Type**: We use `request.destination` to determine resource type. HTML documents usually want to be current (network-first), while static files like CSS, JS, or images can use cache-first strategy.\n\n## Caching Strategies\n\nChoosing the right caching strategy is key for performance and user experience. Different types of resources have different requirements.\n\n### Cache-First Strategy\n\nCache-First is ideal for static files that rarely change:\n\n```javascript\nasync function cacheFirstStrategy(request) {\n  try {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log('[SW] Cache hit:', request.url);\n      return cachedResponse;\n    }\n\n    const networkResponse = await fetch(request);\n    if (networkResponse && networkResponse.status === 200) {\n      const cache = await caches.open(RUNTIME_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    return new Response('Offline - Resource not available', {\n      status: 503,\n      statusText: 'Service Unavailable'\n    });\n  }\n}\n```\n\n**Process**:\n1. First check cache using `caches.match()`\n2. If found in cache, return immediately\n3. If not in cache, download from network\n4. Store successful response in runtime cache for next use\n5. If network also fails, return fallback response\n\n**Advantages**: Extremely fast loading from cache, works completely offline after first visit.\n\n**Disadvantages**: User might see outdated content if file has changed.\n\n**Suitable for**: CSS, JavaScript bundles, fonts, images, icons.\n\n**clone() Method**: HTTP response can only be read once. When we want to return response to client and also store in cache, we must clone it.\n\n### Network-First Strategy\n\nNetwork-First is suitable for frequently changing content:\n\n```javascript\nasync function networkFirstStrategy(request) {\n  try {\n    const networkResponse = await fetch(request);\n    if (networkResponse && networkResponse.status === 200) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log('[SW] Serving from cache (offline):', request.url);\n      return cachedResponse;\n    }\n    return new Response('Offline - Page not cached', {\n      status: 503\n    });\n  }\n}\n```\n\n**Process**:\n1. First try to download from network\n2. Cache successful response\n3. If network fails, try cache\n4. If not in cache either, return error\n\n**Advantages**: User always sees current content (when online), graceful degradation when offline.\n\n**Disadvantages**: Slower loading when network is available (but slow).\n\n**Suitable for**: HTML pages, API requests, frequently changing content.\n\n### Stale-While-Revalidate\n\nThis strategy combines cache speed with network freshness:\n\n```javascript\nasync function staleWhileRevalidate(request) {\n  const cache = await caches.open(CACHE_NAME);\n  const cachedResponse = await cache.match(request);\n\n  const fetchPromise = fetch(request).then(networkResponse => {\n    cache.put(request, networkResponse.clone());\n    return networkResponse;\n  });\n\n  return cachedResponse || fetchPromise;\n}\n```\n\n**Process**:\n1. Load from cache (if exists) and return immediately\n2. Simultaneously start network request in background\n3. When network response arrives, update cache\n4. Next request gets updated version\n\n**Advantages**: Instant response from cache + automatic background update.\n\n**Disadvantages**: User might see outdated content on first view.\n\n**Suitable for**: Avatars, profile icons, feed content.\n\n### Cache-Only and Network-Only\n\n**Cache-Only**: Response only from cache, network isn't used. Suitable for completely static applications or pre-cached resources.\n\n**Network-Only**: Always from network, cache isn't used. Suitable for critical operations or data that must not be cached (payment gateways, personal data).\n\n## Technical Implementation\n\nOur application is built with emphasis on simplicity, performance, and educational value.\n\n### Project Architecture\n\n```\nlab_serviceWorker/\n├── src/\n│   ├── components/         # React components with BEM\n│   ├── styles/            # Global CSS\n│   ├── App.js             # Main component\n│   └── index.js           # Entry point + SW registration\n├── public/\n│   ├── service-worker.js  # Service Worker logic\n│   ├── manifest.json      # PWA manifest\n│   └── index.html         # HTML template\n└── dist/                  # Build output\n```\n\n**Structure Reason**: Components are separated into their own folders with their own CSS files. This supports modularity and makes maintenance easier.\n\n### React Components with BEM\n\nAll components follow BEM (Block Element Modifier) methodology:\n\n**Block**: Independent entity that makes sense on its own (`.header`, `.hero`, `.footer`).\n\n**Element**: Part of block that has no standalone meaning (`.header__logo`, `.header__nav`).\n\n**Modifier**: Variant of block or element (`.button--primary`, `.card--highlighted`).\n\nExample from Header component:\n\n```jsx\n// src/components/Header/Header.js\nfunction Header() {\n  return (\n    <header className=\"header\">\n      <div className=\"header__container\">\n        <div className=\"header__logo\">\n          <BookOpen className=\"header__logo-icon\" />\n          <span className=\"header__logo-text\">Service Worker Edu</span>\n        </div>\n        <nav className=\"header__nav\">\n          <a href=\"#concepts\" className=\"header__nav-link\">Concepts</a>\n        </nav>\n      </div>\n    </header>\n  );\n}\n```\n\n**BEM Advantages**:\n- Clear CSS class structure\n- No naming conflicts\n- Easy maintenance and refactoring\n- Self-documenting code\n\n### Online/Offline Detection\n\nApplication detects connection changes and updates UI:\n\n```javascript\nconst [isOnline, setIsOnline] = useState(navigator.onLine);\n\nuseEffect(() => {\n  const handleOnline = () => setIsOnline(true);\n  const handleOffline = () => setIsOnline(false);\n\n  window.addEventListener('online', handleOnline);\n  window.addEventListener('offline', handleOffline);\n\n  return () => {\n    window.removeEventListener('online', handleOnline);\n    window.removeEventListener('offline', handleOffline);\n  };\n}, []);\n```\n\n**navigator.onLine**: Indicates whether browser has active connection. Note that `true` doesn't mean we have working internet – only that we have network connection.\n\n**online/offline Events**: These events fire when connection status changes. We can react and adjust UI.\n\n### Webpack Configuration\n\nWebpack is used for application bundling:\n\n```javascript\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js',\n    clean: true\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html'\n    }),\n    new CopyWebpackPlugin({\n      patterns: [\n        { from: 'public/service-worker.js', to: 'service-worker.js' },\n        { from: 'public/manifest.json', to: 'manifest.json' }\n      ]\n    })\n  ]\n};\n```\n\n**contenthash**: Adds hash to filename based on content. When content changes, filename changes too, solving cache invalidation.\n\n**CopyWebpackPlugin**: Service Worker must be in root directory to have proper scope. Plugin copies file without bundling.\n\n## Best Practices and Recommendations\n\n### Service Worker Versioning\n\nAlways use version in cache name:\n\n```javascript\nconst CACHE_NAME = 'app-v1';\nconst RUNTIME_CACHE = 'app-runtime-v1';\n```\n\nWhen updating, increment version. Old Service Worker will use old cache, new one creates new cache.\n\n### Cache Separation\n\nSeparate static cache from runtime cache. Static cache contains pre-cached files, runtime cache fills dynamically:\n\n```javascript\n// Static files - cached during install\nconst STATIC_ASSETS = ['/', '/index.html', '/manifest.json'];\n\n// Runtime cache - fills during usage\n// CSS, JS, images are added to runtime cache automatically\n```\n\n### Cache Size\n\nMonitor cache size. Cache API has limits (usually several GB, but depends on browser and available space):\n\n```javascript\nif ('storage' in navigator && 'estimate' in navigator.storage) {\n  navigator.storage.estimate().then(({ usage, quota }) => {\n    console.log(`Using ${usage} out of ${quota} bytes.`);\n  });\n}\n```\n\n### Offline Testing\n\nAlways test offline functionality:\n\n1. Open DevTools\n2. Go to Application tab → Service Workers\n3. Check \"Offline\"\n4. Reload page\n\nApplication should work completely without connection.\n\n### Service Worker Updates\n\nWhen you change Service Worker file (even by one byte), browser detects change and starts installing new Service Worker. However, user might use old version until closing all tabs. Solution:\n\n```javascript\n// In application\nnavigator.serviceWorker.addEventListener('controllerchange', () => {\n  window.location.reload();\n});\n\n// In Service Worker\nself.addEventListener('message', (event) => {\n  if (event.data === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n```\n\n### Service Worker Debugging\n\nChrome DevTools provide excellent tools:\n\n1. **Application tab**: Shows registered Service Workers, cache, manifest\n2. **Console**: Logs from Service Worker (even when page isn't open)\n3. **Network tab**: Marks requests served by Service Worker\n4. **Lighthouse**: PWA compatibility audit\n\n## Performance Optimization\n\n### Precaching vs Runtime Caching\n\n**Precaching** (install event): Cache only essential files needed to display basic page. Excessive precaching slows down installation.\n\n**Runtime caching** (fetch event): Other files are cached on first use. This spreads caching over time.\n\n### Strategic Caching\n\nDifferent file types = different strategies:\n\n- HTML: Network-First (want fresh content)\n- CSS/JS: Cache-First (changes on new build)\n- Images: Cache-First (usually static)\n- API data: Network-First or Stale-While-Revalidate\n\n### Compression\n\nCache API stores responses as received. Make sure server sends compressed content (gzip, brotli).\n\n## Security\n\n### HTTPS Requirement\n\nService Worker requires HTTPS (except localhost). Without HTTPS, attacker could replace Service Worker and intercept all data.\n\n### Response Validation\n\nValidate responses before caching:\n\n```javascript\nif (response && response.status === 200 && response.type === 'basic') {\n  cache.put(request, response.clone());\n}\n```\n\n**response.type**: Can be 'basic' (same-origin), 'cors', 'opaque'. Opaque responses (cross-origin without CORS) can't be read and should be cached carefully.\n\n### Sensitive Data\n\nNever cache sensitive data (passwords, tokens, personal information) without careful consideration. Cache is accessible through DevTools.\n\n## Conclusion\n\nService Worker is a powerful technology that opens doors to offline web applications. Implementation requires careful planning and understanding of lifecycle, but the result is worth it – application that works always, regardless of connection quality.\n\nOur educational application demonstrates all key concepts: registration, installation, activation, different caching strategies, online/offline detection, and best practices. It uses modern stack (React 18, Webpack 5, ES6+) and BEM methodology for maintainable CSS.\n\nService Worker is the foundation of Progressive Web Apps (PWA). With addition of manifest and other PWA features, our application can be installable on desktop and mobile, run in fullscreen, and behave almost identically to native applications.\n\nThe future of the web is in PWA and Service Worker is their heart. Investment in learning this technology definitely pays off – applications will be faster, more reliable, and provide better user experience.\n\n## Resources\n\n- **MDN Web Docs**: Comprehensive Service Worker API documentation\n- **web.dev**: Google guide to PWA and Service Worker best practices\n- **Chrome DevTools**: Tools for debugging and testing\n- **Workbox**: Google library for easier Service Worker work\n\nThis application is open-source and serves as educational material. The code is thoroughly commented and structured for easy understanding. We recommend exploring the source code, experimenting with different strategies, and adapting the solution for your own projects.\n"
}