{
  "title": "Service Worker",
  "description": "Kompletní průvodce offline webovými aplikacemi",
  "markdown": "# Test obsah v češtině\n\nToto je testovací obsah.",
  "tags": [
    "Javascript",
    "Service Worker"
  ],
  "category": "IT",
  "metadata": {
    "readingTime": "20 min",
    "repo": "service-worker"
  },
  "id": "article-1761232130804",
  "date": "2025-10-23",
  "filename": "articles/article-1761232130804.json",
  "title.en": "Service Worker",
  "description.en": "Complete Guide to Offline Web Applications",
  "markdown.en": "# Service Worker: Complete Guide to Offline Web Applications\n\n## Introduction\n\nService Worker is a modern technology that revolutionizes how web applications work. It represents a bridge between classic web pages and native mobile applications. In this article, we'll take a detailed look at implementing an educational application demonstrating Service Worker technology using React, pure JavaScript, and BEM methodology for CSS.\n\nWeb applications traditionally struggle with one fundamental problem – dependency on internet connection. Once you lose network connectivity, the application stops working. Service Worker radically changes this situation. It enables web applications to work offline, cache resources, intercept network requests, and provide users with a seamless experience regardless of connection status.\n\nAs part of this project, we created a comprehensive educational application that not only demonstrates Service Worker technology in practice but also serves as an interactive tutorial. Users can learn key concepts, explore the Service Worker lifecycle, and try out different caching strategies.\n\n## What is Service Worker?\n\nService Worker is a JavaScript file that runs in the background in the browser, separate from the web page. It functions as a proxy server between the web application, browser, and network (when available). This architecture provides several key advantages:\n\n### Main Characteristics\n\n**Separate Thread**: Service Worker runs in its own JavaScript thread, separated from the main page thread. This means it doesn't have direct DOM access and can't block the application's main thread. All communication between Service Worker and the page happens through the postMessage API.\n\n**Event-Driven Architecture**: Service Worker works on an event-driven principle. When something happens (installation, activation, network request), Service Worker responds using event listeners. This architecture is very efficient because Service Worker can be active only when needed, saving system resources.\n\n**HTTPS Requirement**: Service Worker requires HTTPS connection (except localhost for development). This security measure is critical because Service Worker has very powerful capabilities – it can intercept network requests, modify them, and provide custom responses. Without HTTPS, an attacker could replace the Service Worker with malicious code.\n\n**Asynchronous API**: Service Worker uses exclusively asynchronous Promise-based APIs. Synchronous APIs like localStorage or synchronous XHR calls are not available in Service Worker. Instead, we use Cache API and Fetch API, which are modern and performant.\n\n**Lifecycle**: Service Worker has a complex lifecycle that ensures updates happen smoothly and users don't see half-functional states. We'll explore the lifecycle in detail in the next section.\n\n### Why Do We Need Service Worker?\n\n**Offline Functionality**: The main benefit is the ability of the application to work offline. Service Worker can cache all necessary files and provide them even when network connection is unavailable.\n\n**Performance Optimization**: Caching resources means that when reloading the page, we don't need to download the same files again. The application loads instantly from cache, significantly speeding up loading times.\n\n**Background Sync**: Service Worker enables background data synchronization. If a user performs an action offline, Service Worker can queue it and execute when connection is restored.\n\n**Push Notifications**: Service Worker is the foundation for web push notifications. It can receive messages from the server and display notifications even when the user doesn't have the application open.\n\n## Service Worker Lifecycle\n\nUnderstanding the Service Worker lifecycle is absolutely crucial for proper implementation. The lifecycle consists of several phases, each with its purpose.\n\n### Phase 1: Registration\n\nEverything starts with Service Worker registration. In our application, registration happens in `src/index.js`:\n\n```javascript\nif ('serviceWorker' in navigator) {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/service-worker.js')\n      .then(registration => {\n        console.log('✅ Service Worker registered:', registration.scope);\n      })\n      .catch(error => {\n        console.error('❌ Service Worker registration failed:', error);\n      });\n  });\n}\n```\n\n**Why wait for load event?** Service Worker registration can be a demanding operation. If we performed it immediately during page load, it could compete with downloading important resources and slow down first load. By waiting for the load event, we ensure the application is fully loaded before registering the Service Worker.\n\n**Scope**: The `scope` parameter determines which URLs the Service Worker can control. By default, scope is determined by the service worker file location. If `service-worker.js` is in the root directory, it will control the entire domain.\n\n**Conditional Registration**: Before registration, we check if the browser supports Service Worker using `'serviceWorker' in navigator`. Older browsers don't have this property, and the application will work without Service Worker (just without offline capabilities).\n\n### Phase 2: Installation (Install Event)\n\nWhen the browser detects a new Service Worker file (or updated version), it triggers the install event. This is the ideal place to cache static resources:\n\n```javascript\nconst CACHE_NAME = 'sw-edu-app-v1';\nconst STATIC_ASSETS = ['/', '/index.html', '/manifest.json'];\n\nself.addEventListener('install', (event) => {\n  console.log('[SW] Install event');\n\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(STATIC_ASSETS))\n      .then(() => self.skipWaiting())\n  );\n});\n```\n\n**event.waitUntil()**: This method is critical. It tells the browser: \"Wait to complete installation until the Promise inside resolves.\" Without waitUntil, the browser could terminate the Service Worker before all files are cached.\n\n**caches.open()**: Cache API provides storage for HTTP responses. We can have multiple caches with different names. We open (or create) a cache with the given name.\n\n**cache.addAll()**: This method downloads all URLs in the array and stores them in cache. If any file fails, the entire operation fails. This is intentional behavior – we want certainty that we have all important files cached.\n\n**self.skipWaiting()**: Normally, a new Service Worker waits in \"waiting\" state until all pages using the old Service Worker are closed. skipWaiting() skips this wait and activates the new Service Worker immediately. This is useful for quick deployment of updates but can cause issues if we have multiple versions of the application running simultaneously.\n\n**Cache Versioning**: Notice the version in the cache name (`v1`). When we update the application, we increment the version. The old Service Worker will use the old cache, the new Service Worker creates a new cache. In the activate event, we then delete old caches.\n\n### Phase 3: Activation (Activate Event)\n\nAfter successful installation comes activation. The activate event is the ideal place for cleaning up old caches:\n\n```javascript\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activate event');\n\n  event.waitUntil(\n    caches.keys()\n      .then(cacheNames => {\n        return Promise.all(\n          cacheNames.map(cacheName => {\n            if (cacheName !== CACHE_NAME && cacheName !== RUNTIME_CACHE) {\n              console.log('[SW] Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n      .then(() => self.clients.claim())\n  );\n});\n```\n\n**caches.keys()**: Returns an array with names of all caches in the application.\n\n**Cleaning Old Caches**: We iterate through all caches and delete those that don't match the current version. This is important for freeing up space and ensuring we use current files.\n\n**Promise.all()**: We wait for deletion of all old caches. Promise.all() takes an array of promises and returns a promise that resolves when all promises in the array resolve.\n\n**clients.claim()**: Normally, Service Worker starts controlling pages only on their next load. claim() tells the Service Worker: \"Take control of all existing pages immediately.\" This is useful in combination with skipWaiting() for immediate activation of new Service Worker.\n\n### Phase 4: Fetch Events\n\nAfter activation, Service Worker is fully functional and can intercept network requests using the fetch event:\n\n```javascript\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  if (!url.protocol.startsWith('http')) return;\n  if (url.origin !== self.location.origin) return;\n\n  if (request.destination === 'document') {\n    event.respondWith(networkFirstStrategy(request));\n  } else {\n    event.respondWith(cacheFirstStrategy(request));\n  }\n});\n```\n\n**Request Interception**: Every HTTP(S) request the application makes goes through Service Worker's fetch event. We can decide how to respond to the request.\n\n**event.respondWith()**: This method allows us to provide a custom response to the request. We can return a cached response, make our own network request, or create a response completely dynamically.\n\n**Request Filtering**: It's not appropriate to intercept all requests. We should ignore non-HTTP protocols (chrome-extension://, etc.) and requests to other domains (due to CORS).\n\n**Decision by Type**: We use `request.destination` to determine resource type. HTML documents usually want to be current (network-first), while static files like CSS, JS, or images can use cache-first strategy.\n\n## Caching Strategies\n\nChoosing the right caching strategy is key for performance and user experience. Different types of resources have different requirements.\n\n### Cache-First Strategy\n\nCache-First is ideal for static files that rarely change:\n\n```javascript\nasync function cacheFirstStrategy(request) {\n  try {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log('[SW] Cache hit:', request.url);\n      return cachedResponse;\n    }\n\n    const networkResponse = await fetch(request);\n    if (networkResponse && networkResponse.status === 200) {\n      const cache = await caches.open(RUNTIME_CACHE);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    return new Response('Offline - Resource not available', {\n      status: 503,\n      statusText: 'Service Unavailable'\n    });\n  }\n}\n```\n\n**Process**:\n1. First check cache using `caches.match()`\n2. If found in cache, return immediately\n3. If not in cache, download from network\n4. Store successful response in runtime cache for next use\n5. If network also fails, return fallback response\n\n**Advantages**: Extremely fast loading from cache, works completely offline after first visit.\n\n**Disadvantages**: User might see outdated content if file has changed.\n\n**Suitable for**: CSS, JavaScript bundles, fonts, images, icons.\n\n**clone() Method**: HTTP response can only be read once. When we want to return response to client and also store in cache, we must clone it.\n\n### Network-First Strategy\n\nNetwork-First is suitable for frequently changing content:\n\n```javascript\nasync function networkFirstStrategy(request) {\n  try {\n    const networkResponse = await fetch(request);\n    if (networkResponse && networkResponse.status === 200) {\n      const cache = await caches.open(CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      console.log('[SW] Serving from cache (offline):', request.url);\n      return cachedResponse;\n    }\n    return new Response('Offline - Page not cached', {\n      status: 503\n    });\n  }\n}\n```\n\n**Process**:\n1. First try to download from network\n2. Cache successful response\n3. If network fails, try cache\n4. If not in cache either, return error\n\n**Advantages**: User always sees current content (when online), graceful degradation when offline.\n\n**Disadvantages**: Slower loading when network is available (but slow).\n\n**Suitable for**: HTML pages, API requests, frequently changing content.\n\n### Stale-While-Revalidate\n\nThis strategy combines cache speed with network freshness:\n\n```javascript\nasync function staleWhileRevalidate(request) {\n  const cache = await caches.open(CACHE_NAME);\n  const cachedResponse = await cache.match(request);\n\n  const fetchPromise = fetch(request).then(networkResponse => {\n    cache.put(request, networkResponse.clone());\n    return networkResponse;\n  });\n\n  return cachedResponse || fetchPromise;\n}\n```\n\n**Process**:\n1. Load from cache (if exists) and return immediately\n2. Simultaneously start network request in background\n3. When network response arrives, update cache\n4. Next request gets updated version\n\n**Advantages**: Instant response from cache + automatic background update.\n\n**Disadvantages**: User might see outdated content on first view.\n\n**Suitable for**: Avatars, profile icons, feed content.\n\n### Cache-Only and Network-Only\n\n**Cache-Only**: Response only from cache, network isn't used. Suitable for completely static applications or pre-cached resources.\n\n**Network-Only**: Always from network, cache isn't used. Suitable for critical operations or data that must not be cached (payment gateways, personal data).\n\n## Technical Implementation\n\nOur application is built with emphasis on simplicity, performance, and educational value.\n\n### Project Architecture\n\n```\nlab_serviceWorker/\n├── src/\n│   ├── components/         # React components with BEM\n│   ├── styles/            # Global CSS\n│   ├── App.js             # Main component\n│   └── index.js           # Entry point + SW registration\n├── public/\n│   ├── service-worker.js  # Service Worker logic\n│   ├── manifest.json      # PWA manifest\n│   └── index.html         # HTML template\n└── dist/                  # Build output\n```\n\n**Structure Reason**: Components are separated into their own folders with their own CSS files. This supports modularity and makes maintenance easier.\n\n### React Components with BEM\n\nAll components follow BEM (Block Element Modifier) methodology:\n\n**Block**: Independent entity that makes sense on its own (`.header`, `.hero`, `.footer`).\n\n**Element**: Part of block that has no standalone meaning (`.header__logo`, `.header__nav`).\n\n**Modifier**: Variant of block or element (`.button--primary`, `.card--highlighted`).\n\nExample from Header component:\n\n```jsx\n// src/components/Header/Header.js\nfunction Header() {\n  return (\n    <header className=\"header\">\n      <div className=\"header__container\">\n        <div className=\"header__logo\">\n          <BookOpen className=\"header__logo-icon\" />\n          <span className=\"header__logo-text\">Service Worker Edu</span>\n        </div>\n        <nav className=\"header__nav\">\n          <a href=\"#concepts\" className=\"header__nav-link\">Concepts</a>\n        </nav>\n      </div>\n    </header>\n  );\n}\n```\n\n**BEM Advantages**:\n- Clear CSS class structure\n- No naming conflicts\n- Easy maintenance and refactoring\n- Self-documenting code\n\n### Online/Offline Detection\n\nApplication detects connection changes and updates UI:\n\n```javascript\nconst [isOnline, setIsOnline] = useState(navigator.onLine);\n\nuseEffect(() => {\n  const handleOnline = () => setIsOnline(true);\n  const handleOffline = () => setIsOnline(false);\n\n  window.addEventListener('online', handleOnline);\n  window.addEventListener('offline', handleOffline);\n\n  return () => {\n    window.removeEventListener('online', handleOnline);\n    window.removeEventListener('offline', handleOffline);\n  };\n}, []);\n```\n\n**navigator.onLine**: Indicates whether browser has active connection. Note that `true` doesn't mean we have working internet – only that we have network connection.\n\n**online/offline Events**: These events fire when connection status changes. We can react and adjust UI.\n\n### Webpack Configuration\n\nWebpack is used for application bundling:\n\n```javascript\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.[contenthash].js',\n    clean: true\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: './public/index.html'\n    }),\n    new CopyWebpackPlugin({\n      patterns: [\n        { from: 'public/service-worker.js', to: 'service-worker.js' },\n        { from: 'public/manifest.json', to: 'manifest.json' }\n      ]\n    })\n  ]\n};\n```\n\n**contenthash**: Adds hash to filename based on content. When content changes, filename changes too, solving cache invalidation.\n\n**CopyWebpackPlugin**: Service Worker must be in root directory to have proper scope. Plugin copies file without bundling.\n\n## Best Practices and Recommendations\n\n### Service Worker Versioning\n\nAlways use version in cache name:\n\n```javascript\nconst CACHE_NAME = 'app-v1';\nconst RUNTIME_CACHE = 'app-runtime-v1';\n```\n\nWhen updating, increment version. Old Service Worker will use old cache, new one creates new cache.\n\n### Cache Separation\n\nSeparate static cache from runtime cache. Static cache contains pre-cached files, runtime cache fills dynamically:\n\n```javascript\n// Static files - cached during install\nconst STATIC_ASSETS = ['/', '/index.html', '/manifest.json'];\n\n// Runtime cache - fills during usage\n// CSS, JS, images are added to runtime cache automatically\n```\n\n### Cache Size\n\nMonitor cache size. Cache API has limits (usually several GB, but depends on browser and available space):\n\n```javascript\nif ('storage' in navigator && 'estimate' in navigator.storage) {\n  navigator.storage.estimate().then(({ usage, quota }) => {\n    console.log(`Using ${usage} out of ${quota} bytes.`);\n  });\n}\n```\n\n### Offline Testing\n\nAlways test offline functionality:\n\n1. Open DevTools\n2. Go to Application tab → Service Workers\n3. Check \"Offline\"\n4. Reload page\n\nApplication should work completely without connection.\n\n### Service Worker Updates\n\nWhen you change Service Worker file (even by one byte), browser detects change and starts installing new Service Worker. However, user might use old version until closing all tabs. Solution:\n\n```javascript\n// In application\nnavigator.serviceWorker.addEventListener('controllerchange', () => {\n  window.location.reload();\n});\n\n// In Service Worker\nself.addEventListener('message', (event) => {\n  if (event.data === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n```\n\n### Service Worker Debugging\n\nChrome DevTools provide excellent tools:\n\n1. **Application tab**: Shows registered Service Workers, cache, manifest\n2. **Console**: Logs from Service Worker (even when page isn't open)\n3. **Network tab**: Marks requests served by Service Worker\n4. **Lighthouse**: PWA compatibility audit\n\n## Performance Optimization\n\n### Precaching vs Runtime Caching\n\n**Precaching** (install event): Cache only essential files needed to display basic page. Excessive precaching slows down installation.\n\n**Runtime caching** (fetch event): Other files are cached on first use. This spreads caching over time.\n\n### Strategic Caching\n\nDifferent file types = different strategies:\n\n- HTML: Network-First (want fresh content)\n- CSS/JS: Cache-First (changes on new build)\n- Images: Cache-First (usually static)\n- API data: Network-First or Stale-While-Revalidate\n\n### Compression\n\nCache API stores responses as received. Make sure server sends compressed content (gzip, brotli).\n\n## Security\n\n### HTTPS Requirement\n\nService Worker requires HTTPS (except localhost). Without HTTPS, attacker could replace Service Worker and intercept all data.\n\n### Response Validation\n\nValidate responses before caching:\n\n```javascript\nif (response && response.status === 200 && response.type === 'basic') {\n  cache.put(request, response.clone());\n}\n```\n\n**response.type**: Can be 'basic' (same-origin), 'cors', 'opaque'. Opaque responses (cross-origin without CORS) can't be read and should be cached carefully.\n\n### Sensitive Data\n\nNever cache sensitive data (passwords, tokens, personal information) without careful consideration. Cache is accessible through DevTools.\n\n## Conclusion\n\nService Worker is a powerful technology that opens doors to offline web applications. Implementation requires careful planning and understanding of lifecycle, but the result is worth it – application that works always, regardless of connection quality.\n\nOur educational application demonstrates all key concepts: registration, installation, activation, different caching strategies, online/offline detection, and best practices. It uses modern stack (React 18, Webpack 5, ES6+) and BEM methodology for maintainable CSS.\n\nService Worker is the foundation of Progressive Web Apps (PWA). With addition of manifest and other PWA features, our application can be installable on desktop and mobile, run in fullscreen, and behave almost identically to native applications.\n\nThe future of the web is in PWA and Service Worker is their heart. Investment in learning this technology definitely pays off – applications will be faster, more reliable, and provide better user experience.\n\n## Resources\n\n- **MDN Web Docs**: Comprehensive Service Worker API documentation\n- **web.dev**: Google guide to PWA and Service Worker best practices\n- **Chrome DevTools**: Tools for debugging and testing\n- **Workbox**: Google library for easier Service Worker work\n\nThis application is open-source and serves as educational material. The code is thoroughly commented and structured for easy understanding. We recommend exploring the source code, experimenting with different strategies, and adapting the solution for your own projects.\n",
  "tags.en": [
    "Javascript",
    "Service Worker"
  ]
}