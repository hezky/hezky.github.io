{
  "id": "article-1753439557521",
  "title": "Čistý kód v praxi: Kompletní refaktoring React aplikace",
  "date": "2025-07-25",
  "description": "Čistý kód není jen o estetice nebo akademických principech. Je to praktický nástroj, který šetří čas, peníze a nervy. V tomto článku vám ukážu, jak jsem kompletně refaktoroval React aplikaci podle principů čistého kódu - od monolitického 566řádkového souboru až po modulární, čitelnou a udržitelnou architekturu.",
  "tags": [
    "React",
    "Javascript",
    "frontend",
    "clean code"
  ],
  "category": "tutorial",
  "markdown": "# Čistý kód v praxi: Kompletní refaktoring React aplikace\n\n## Úvod: Proč je čistý kód důležitý?\n\nPředstavte si, že přicházíte k projektu po půl roce. Nebo ještě lépe - představte si, že k vašemu kódu přichází nový kolega. Dokáže se v něm zorientovat? Pochopí, co která část dělá? Najde snadno místo, kde potřebuje provést změnu?\n\nČistý kód není jen o estetice nebo akademických principech. Je to praktický nástroj, který šetří čas, peníze a nervy. V tomto článku vám ukážu, jak jsem kompletně refaktoroval React aplikaci podle principů čistého kódu - od monolitického 566řádkového souboru až po modulární, čitelnou a udržitelnou architekturu.\n\n## Výchozí stav: Analýza problémů\n\nPůvodní aplikace byla funkční demonstrace problému s použitím indexů jako ID v knihovně @dnd-kit. Celý kód byl však v jednom souboru `App.jsx` s 566 řádky. Pojďme se podívat na hlavní problémy:\n\n### 1. Monolitická struktura\n```javascript\n// Vše v jednom souboru\nfunction SortableItem({ id, value, onDelete, isWrong, debugInfo }) {\n  // 40+ řádků kódu\n}\n\nexport default function App() {\n  // 450+ řádků kódu\n  // Všechna logika, UI, handlery, utility funkce...\n}\n```\n\n### 2. Magické konstanty\n```javascript\nconst [showDebug, setShowDebug] = useState(true);\nconst [activeTab, setActiveTab] = useState('all'); // Co je 'all'?\n\n// Později v kódu\nif (activeTab === 'wrong') { // Magický string\n  // ...\n}\n\n// Historie\nsetDragHistory(prev => [...prev.slice(-5)]); // Proč 5?\n```\n\n### 3. Duplicitní kód\n```javascript\n// Handler pro wrong variantu\nconst handleWrongDragEnd = (event) => {\n  const { active, over } = event;\n  if (active.id !== over.id) {\n    // Logika přesunu\n  }\n};\n\n// Handler pro correct variantu - téměř identický\nconst handleCorrectDragEnd = (event) => {\n  const { active, over } = event;\n  if (active.id !== over.id) {\n    // Skoro stejná logika přesunu\n  }\n};\n```\n\n### 4. Míchání zodpovědností\n```javascript\n// Generátory ID smíchané s komponentami\nlet idCounter = 0;\nconst generateId = () => `item-${++idCounter}`;\n\nconst generateUUID = () => {\n  // 10 řádků implementace\n};\n\n// Hned za tím komponenta\nfunction SortableItem({ ... }) {\n  // UI logika\n}\n```\n\n## Principy čistého kódu, které jsem aplikoval\n\n### 1. Single Responsibility Principle (SRP)\nKaždý modul, třída nebo funkce by měla mít jednu a pouze jednu zodpovědnost.\n\n**Před refaktoringem:**\n```javascript\nexport default function App() {\n  // Generování ID\n  // Správa historie\n  // Drag & drop logika\n  // UI renderování\n  // Event handling\n  // ... všechno pohromadě\n}\n```\n\n**Po refaktoringu:**\n```javascript\n// utils/idGenerators.js - pouze generování ID\nexport const generateNanoId = (size = 8) => { /* ... */ };\n\n// hooks/useHistory.js - pouze správa historie\nexport const useHistory = () => { /* ... */ };\n\n// components/SortableItem.jsx - pouze UI komponenta\nexport default React.memo(SortableItem);\n```\n\n### 2. DRY (Don't Repeat Yourself)\nEliminace duplicit a vytvoření znovupoužitelných abstrakcí.\n\n**Před refaktoringem:**\nTři téměř identické handlery pro drag & drop.\n\n**Po refaktoringu:**\n```javascript\n// hooks/useDragAndDrop.js\nexport const useDragAndDrop = (initialItems, findIndexById) => {\n  // Univerzální logika pro všechny varianty\n  const handleDragEnd = useCallback((event) => {\n    // Společná implementace\n  }, [items, findIndexById]);\n  \n  return { items, handleDragEnd, deleteItem, addItem };\n};\n```\n\n### 3. Pojmenované konstanty místo magických hodnot\n**Před:**\n```javascript\nif (activeTab === 'wrong') { }\nhistory.slice(-5)\nopacity: isDragging ? 0.5 : 1\n```\n\n**Po:**\n```javascript\n// constants/index.js\nexport const VARIANT_TYPES = {\n  WRONG: 'wrong',\n  GENERATED: 'generated',\n  CORRECT: 'correct',\n  ALL: 'all'\n};\n\nexport const UI_CONSTANTS = {\n  HISTORY_DISPLAY_LIMIT: 5,\n  DRAGGING_OPACITY: 0.5,\n  DEFAULT_OPACITY: 1\n};\n\n// Použití\nif (activeTab === VARIANT_TYPES.WRONG) { }\n```\n\n### 4. Separation of Concerns\nOddělení různých vrstev aplikace.\n\n**Struktura po refaktoringu:**\n```\nsrc/\n├── components/        # UI komponenty\n│   ├── Header.jsx\n│   ├── SortableItem.jsx\n│   └── variants/      # Varianty demonstrace\n├── hooks/            # Business logika\n│   ├── useHistory.js\n│   └── useDragAndDrop.js\n├── utils/            # Utility funkce\n│   └── idGenerators.js\n└── constants/        # Konfigurace\n    └── index.js\n```\n\n### 5. Pure funkce a immutabilita\n**Před:**\n```javascript\nlet idCounter = 0; // Globální mutable state\nconst generateId = () => `item-${++idCounter}`; // Side effect\n```\n\n**Po:**\n```javascript\n// Pure funkce bez side effectů\nexport const generateNanoId = (size = 8) => {\n  const alphabet = 'ABCD...';\n  let result = '';\n  for (let i = 0; i < size; i++) {\n    result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n  }\n  return result;\n};\n```\n\n### 6. Early returns pro lepší čitelnost\n**Před:**\n```javascript\nconst handleDelete = (id) => {\n  const item = items.find(item => item.id === id);\n  if (item) {\n    // Dlouhý blok kódu\n    // ...\n    // ...\n  }\n};\n```\n\n**Po:**\n```javascript\nconst handleDelete = (id) => {\n  const item = items.find(item => item.id === id);\n  if (!item) return; // Early return\n  \n  // Hlavní logika bez zbytečného zanořování\n  deleteItem(id);\n  addHistoryEntry(/* ... */);\n};\n```\n\n## Proces refaktoringu krok za krokem\n\n### Krok 1: Analýza a plánování\nNejprve jsem vytvořil `CLEAN_CODE_PRINCIPLES.md` se souhrnem principů a `projectplan.md` s detailním checklistem. Plánování je klíčové - bez něj bychom se ztratili v chaosu změn.\n\n### Krok 2: Vytvoření struktury složek\n```bash\nmkdir -p src/{components,hooks,utils,constants}\n```\n\n### Krok 3: Extrakce konstant\nPrvní věc, kterou jsem udělal, bylo vytvoření `constants/index.js`. To mi umožnilo:\n- Centralizovat všechny magické hodnoty\n- Snadno měnit konfiguraci\n- Mít přehled o všech konstantách v aplikaci\n\n### Krok 4: Vytvoření utility funkcí\nExtrakce generátorů ID do `utils/idGenerators.js`:\n- Oddělení utility logiky od komponent\n- Možnost jednotkového testování\n- Znovupoužitelnost v jiných projektech\n\n### Krok 5: Custom hooks\nVytvoření `useHistory` a `useDragAndDrop` hooks:\n- Zapouzdření state managementu\n- Oddělení business logiky od UI\n- Testovatelnost pomocí React Testing Library\n\n### Krok 6: Rozdělení komponent\nSystematické rozdělení monolitického App.jsx:\n1. `Header.jsx` - statická hlavička\n2. `Controls.jsx` - ovládací prvky\n3. `SortableItem.jsx` - jednotlivé položky\n4. `variants/` - jednotlivé demonstrační varianty\n\n### Krok 7: Optimalizace výkonu\n- `React.memo` pro komponenty bez častých změn\n- `useCallback` pro event handlery\n- `useMemo` pro výpočetně náročné operace\n\n## Výsledky refaktoringu\n\n### Metriky kódu\n\n**Před refaktoringem:**\n- 1 soubor, 566 řádků\n- Cyklomatická složitost: vysoká\n- Duplicity: 3 téměř identické handlery\n- Testovatelnost: velmi nízká\n\n**Po refaktoringu:**\n- 15+ modulárních souborů\n- Průměrná délka souboru: ~80 řádků\n- Žádné duplicity\n- Vysoká testovatelnost\n\n### Výhody pro development\n\n1. **Snadnější orientace**: Nový vývojář najde potřebnou část kódu během sekund\n2. **Bezpečnější změny**: Změna v jednom modulu neovlivní ostatní\n3. **Lepší debugging**: Chyby jsou lokalizované v konkrétních modulech\n4. **Týmová spolupráce**: Více lidí může pracovat paralelně bez konfliktů\n\n### Zachování funkcionality\n\nDůležité: Aplikace funguje identicky jako před refaktoringem. Žádná funkcionalita nebyla odebrána ani změněna. To je klíčový princip refaktoringu - měníme strukturu, ne chování.\n\n## Praktické tipy pro váš refaktoring\n\n### 1. Začněte malými kroky\nNepokoušejte se refaktorovat vše najednou. Začněte extrakcí konstant nebo jedné utility funkce.\n\n### 2. Testujte průběžně\nPo každé změně ověřte, že aplikace stále funguje. Ideálně mějte automatické testy.\n\n### 3. Používejte Git\nCommitujte často s popisnými zprávami. Při problémech se snadno vrátíte.\n\n### 4. Dokumentujte rozhodnutí\nNapište si, proč jste se rozhodli pro konkrétní strukturu. Za půl roku si nebudete pamatovat kontext.\n\n### 5. Code review\nPožádejte kolegu o review. Druhý pár očí často odhalí věci, které přehlédnete.\n\n## Časté chyby při refaktoringu\n\n### 1. Over-engineering\nNetvořte abstrakce pro jediné použití. YAGNI (You Ain't Gonna Need It).\n\n### 2. Změna funkcionality\nRefaktoring = změna struktury, ne chování. Odolte pokušení \"vylepšit\" funkce.\n\n### 3. Nedostatečné testování\nBez testů je refaktoring hazard. Minimálně manuálně otestujte všechny use cases.\n\n### 4. Ignorování výkonu\nČistý kód by měl být i výkonný. Měřte performance před a po změnách.\n\n## Best practices, které doporučuji\n\n### 1. Konvence pojmenování\n```javascript\n// Komponenty - PascalCase\nSortableItem.jsx\n\n// Utility funkce - camelCase, popisné\ngenerateNanoId()\n\n// Konstanty - UPPER_CASE\nVARIANT_TYPES.WRONG\n\n// Event handlery - handle prefix\nhandleDragEnd()\n```\n\n### 2. Struktura souborů\n```javascript\n// 1. Hlavičkový komentář\n// 2. Importy (rozdělené do logických skupin)\n// 3. Komponenta/funkce\n// 4. Export\n\n// src/components/SortableItem.jsx\n// Komponenta pro jednotlivé přetahovatelné položky\n// Tato komponenta neobsahuje business logiku, pouze UI reprezentaci\n\nimport React from 'react';\nimport { useSortable } from '@dnd-kit/sortable';\n// ...\n\nconst SortableItem = () => {\n  // ...\n};\n\nexport default React.memo(SortableItem);\n```\n\n### 3. Komentáře\nPíšu komentáře, které vysvětlují \"proč\", ne \"co\":\n```javascript\n// ❌ Špatně\n// Přičteme 1 k counteru\ncounter++;\n\n// ✅ Dobře\n// Zvýšíme counter, protože každá položka musí mít unikátní ID\ncounter++;\n```\n\n## Závěr: Cesta k udržitelnému kódu\n\nRefaktoring této aplikace mi zabral několik hodin, ale vyplatí se to mnohonásobně. Každá budoucí změna bude rychlejší a bezpečnější. Nový člen týmu se zorientuje během minut, ne hodin.\n\nČistý kód není luxus ani akademická cvičení. Je to profesionální odpovědnost každého vývojáře. Váš budoucí já (a vaši kolegové) vám poděkují.\n\nPamatujte: **Kód čteme mnohem častěji, než ho píšeme.** Investice do čitelnosti se vždy vyplatí.\n\n## Další kroky\n\n1. **Přidejte testy**: Unit testy pro utility funkce, integration testy pro komponenty\n2. **TypeScript**: Přidání typové bezpečnosti\n3. **Storybook**: Dokumentace komponent\n4. **CI/CD**: Automatické kontroly kvality kódu\n\nČistý kód je cesta, ne cíl. Každý projekt je příležitostí k učení a zlepšování. Začněte dnes - váš kód bude lepší už zítra.\n\n---\n\n*Tento článek vznikl při refaktoringu reálné aplikace. Všechny ukázky kódu jsou z produkčního projektu. Kompletní zdrojový kód najdete v [repozitáři na github](https://github.com/hezky/example_dndKitIndexProblem.git).*",
  "metadata": {
    "author": "David Hezky",
    "readingTime": "8 min"
  },
  "title.en": "Clean Code in Practice: Complete React Application Refactoring",
  "description.en": "Clean code isn't just about aesthetics or academic principles. It's a practical tool that saves time, money, and nerves. In this article, I'll show you how I completely refactored a React application following clean code principles - from a monolithic 566-line file to a modular, readable, and maintainable architecture.",
  "markdown.en": "# Clean Code in Practice: Complete React Application Refactoring\n\n## Introduction: Why Clean Code Matters\n\nImagine coming back to a project after six months. Or better yet - imagine a new colleague approaching your code. Can they navigate it? Do they understand what each part does? Can they easily find where to make changes?\n\nClean code isn't just about aesthetics or academic principles. It's a practical tool that saves time, money, and nerves. In this article, I'll show you how I completely refactored a React application following clean code principles - from a monolithic 566-line file to a modular, readable, and maintainable architecture.\n\n## Initial State: Problem Analysis\n\nThe original application was a functional demonstration of the problem with using indexes as IDs in the @dnd-kit library. However, all the code was in a single `App.jsx` file with 566 lines. Let's look at the main problems:\n\n### 1. Monolithic Structure\n```javascript\n// Everything in one file\nfunction SortableItem({ id, value, onDelete, isWrong, debugInfo }) {\n  // 40+ lines of code\n}\n\nexport default function App() {\n  // 450+ lines of code\n  // All logic, UI, handlers, utility functions...\n}\n```\n\n### 2. Magic Constants\n```javascript\nconst [showDebug, setShowDebug] = useState(true);\nconst [activeTab, setActiveTab] = useState('all'); // What is 'all'?\n\n// Later in code\nif (activeTab === 'wrong') { // Magic string\n  // ...\n}\n\n// History\nsetDragHistory(prev => [...prev.slice(-5)]); // Why 5?\n```\n\n### 3. Duplicate Code\n```javascript\n// Handler for wrong variant\nconst handleWrongDragEnd = (event) => {\n  const { active, over } = event;\n  if (active.id !== over.id) {\n    // Move logic\n  }\n};\n\n// Handler for correct variant - almost identical\nconst handleCorrectDragEnd = (event) => {\n  const { active, over } = event;\n  if (active.id !== over.id) {\n    // Almost same move logic\n  }\n};\n```\n\n### 4. Mixed Responsibilities\n```javascript\n// ID generators mixed with components\nlet idCounter = 0;\nconst generateId = () => `item-${++idCounter}`;\n\nconst generateUUID = () => {\n  // 10 lines of implementation\n};\n\n// Component right after\nfunction SortableItem({ ... }) {\n  // UI logic\n}\n```\n\n## Clean Code Principles I Applied\n\n### 1. Single Responsibility Principle (SRP)\nEach module, class, or function should have one and only one responsibility.\n\n**Before refactoring:**\n```javascript\nexport default function App() {\n  // ID generation\n  // History management\n  // Drag & drop logic\n  // UI rendering\n  // Event handling\n  // ... everything together\n}\n```\n\n**After refactoring:**\n```javascript\n// utils/idGenerators.js - only ID generation\nexport const generateNanoId = (size = 8) => { /* ... */ };\n\n// hooks/useHistory.js - only history management\nexport const useHistory = () => { /* ... */ };\n\n// components/SortableItem.jsx - only UI component\nexport default React.memo(SortableItem);\n```\n\n### 2. DRY (Don't Repeat Yourself)\nEliminating duplicates and creating reusable abstractions.\n\n**Before refactoring:**\nThree almost identical drag & drop handlers.\n\n**After refactoring:**\n```javascript\n// hooks/useDragAndDrop.js\nexport const useDragAndDrop = (initialItems, findIndexById) => {\n  // Universal logic for all variants\n  const handleDragEnd = useCallback((event) => {\n    // Shared implementation\n  }, [items, findIndexById]);\n  \n  return { items, handleDragEnd, deleteItem, addItem };\n};\n```\n\n### 3. Named Constants Instead of Magic Values\n**Before:**\n```javascript\nif (activeTab === 'wrong') { }\nhistory.slice(-5)\nopacity: isDragging ? 0.5 : 1\n```\n\n**After:**\n```javascript\n// constants/index.js\nexport const VARIANT_TYPES = {\n  WRONG: 'wrong',\n  GENERATED: 'generated',\n  CORRECT: 'correct',\n  ALL: 'all'\n};\n\nexport const UI_CONSTANTS = {\n  HISTORY_DISPLAY_LIMIT: 5,\n  DRAGGING_OPACITY: 0.5,\n  DEFAULT_OPACITY: 1\n};\n\n// Usage\nif (activeTab === VARIANT_TYPES.WRONG) { }\n```\n\n### 4. Separation of Concerns\nSeparating different layers of the application.\n\n**Structure after refactoring:**\n```\nsrc/\n├── components/        # UI components\n│   ├── Header.jsx\n│   ├── SortableItem.jsx\n│   └── variants/      # Demo variants\n├── hooks/            # Business logic\n│   ├── useHistory.js\n│   └── useDragAndDrop.js\n├── utils/            # Utility functions\n│   └── idGenerators.js\n└── constants/        # Configuration\n    └── index.js\n```\n\n### 5. Pure Functions and Immutability\n**Before:**\n```javascript\nlet idCounter = 0; // Global mutable state\nconst generateId = () => `item-${++idCounter}`; // Side effect\n```\n\n**After:**\n```javascript\n// Pure function without side effects\nexport const generateNanoId = (size = 8) => {\n  const alphabet = 'ABCD...';\n  let result = '';\n  for (let i = 0; i < size; i++) {\n    result += alphabet.charAt(Math.floor(Math.random() * alphabet.length));\n  }\n  return result;\n};\n```\n\n### 6. Early Returns for Better Readability\n**Before:**\n```javascript\nconst handleDelete = (id) => {\n  const item = items.find(item => item.id === id);\n  if (item) {\n    // Long code block\n    // ...\n    // ...\n  }\n};\n```\n\n**After:**\n```javascript\nconst handleDelete = (id) => {\n  const item = items.find(item => item.id === id);\n  if (!item) return; // Early return\n  \n  // Main logic without unnecessary nesting\n  deleteItem(id);\n  addHistoryEntry(/* ... */);\n};\n```\n\n## Refactoring Process Step by Step\n\n### Step 1: Analysis and Planning\nFirst, I created `CLEAN_CODE_PRINCIPLES.md` with a summary of principles and `projectplan.md` with a detailed checklist. Planning is crucial - without it, we'd get lost in the chaos of changes.\n\n### Step 2: Creating Folder Structure\n```bash\nmkdir -p src/{components,hooks,utils,constants}\n```\n\n### Step 3: Extracting Constants\nThe first thing I did was create `constants/index.js`. This allowed me to:\n- Centralize all magic values\n- Easily change configuration\n- Have an overview of all constants in the application\n\n### Step 4: Creating Utility Functions\nExtracting ID generators to `utils/idGenerators.js`:\n- Separating utility logic from components\n- Enabling unit testing\n- Reusability in other projects\n\n### Step 5: Custom Hooks\nCreating `useHistory` and `useDragAndDrop` hooks:\n- Encapsulating state management\n- Separating business logic from UI\n- Testability with React Testing Library\n\n### Step 6: Splitting Components\nSystematic division of monolithic App.jsx:\n1. `Header.jsx` - static header\n2. `Controls.jsx` - control elements\n3. `SortableItem.jsx` - individual items\n4. `variants/` - individual demo variants\n\n### Step 7: Performance Optimization\n- `React.memo` for components without frequent changes\n- `useCallback` for event handlers\n- `useMemo` for computationally expensive operations\n\n## Refactoring Results\n\n### Code Metrics\n\n**Before refactoring:**\n- 1 file, 566 lines\n- Cyclomatic complexity: high\n- Duplicates: 3 almost identical handlers\n- Testability: very low\n\n**After refactoring:**\n- 15+ modular files\n- Average file length: ~80 lines\n- No duplicates\n- High testability\n\n### Development Benefits\n\n1. **Easier Navigation**: New developers find needed code parts in seconds\n2. **Safer Changes**: Changes in one module don't affect others\n3. **Better Debugging**: Errors are localized in specific modules\n4. **Team Collaboration**: Multiple people can work in parallel without conflicts\n\n### Preserved Functionality\n\nImportant: The application works identically to before refactoring. No functionality was removed or changed. This is a key principle of refactoring - we change structure, not behavior.\n\n## Practical Tips for Your Refactoring\n\n### 1. Start with Small Steps\nDon't try to refactor everything at once. Start by extracting constants or one utility function.\n\n### 2. Test Continuously\nAfter each change, verify the application still works. Ideally have automated tests.\n\n### 3. Use Git\nCommit often with descriptive messages. Easy to revert if problems arise.\n\n### 4. Document Decisions\nWrite down why you decided on specific structure. In six months, you won't remember the context.\n\n### 5. Code Review\nAsk a colleague for review. A second pair of eyes often reveals things you overlook.\n\n## Common Refactoring Mistakes\n\n### 1. Over-engineering\nDon't create abstractions for single use. YAGNI (You Ain't Gonna Need It).\n\n### 2. Changing Functionality\nRefactoring = changing structure, not behavior. Resist the temptation to \"improve\" features.\n\n### 3. Insufficient Testing\nWithout tests, refactoring is hazardous. At minimum, manually test all use cases.\n\n### 4. Ignoring Performance\nClean code should also be performant. Measure performance before and after changes.\n\n## Best Practices I Recommend\n\n### 1. Naming Conventions\n```javascript\n// Components - PascalCase\nSortableItem.jsx\n\n// Utility functions - camelCase, descriptive\ngenerateNanoId()\n\n// Constants - UPPER_CASE\nVARIANT_TYPES.WRONG\n\n// Event handlers - handle prefix\nhandleDragEnd()\n```\n\n### 2. File Structure\n```javascript\n// 1. Header comment\n// 2. Imports (divided into logical groups)\n// 3. Component/function\n// 4. Export\n\n// src/components/SortableItem.jsx\n// Component for individual draggable items\n// This component contains no business logic, only UI representation\n\nimport React from 'react';\nimport { useSortable } from '@dnd-kit/sortable';\n// ...\n\nconst SortableItem = () => {\n  // ...\n};\n\nexport default React.memo(SortableItem);\n```\n\n### 3. Comments\nWrite comments that explain \"why\", not \"what\":\n```javascript\n// ❌ Bad\n// Add 1 to counter\ncounter++;\n\n// ✅ Good\n// Increment counter because each item must have unique ID\ncounter++;\n```\n\n## Conclusion: The Path to Maintainable Code\n\nRefactoring this application took several hours, but it pays off many times over. Every future change will be faster and safer. New team members will orient themselves in minutes, not hours.\n\nClean code isn't luxury or academic exercise. It's the professional responsibility of every developer. Your future self (and your colleagues) will thank you.\n\nRemember: **We read code much more often than we write it.** Investment in readability always pays off.\n\n## Next Steps\n\n1. **Add Tests**: Unit tests for utility functions, integration tests for components\n2. **TypeScript**: Add type safety\n3. **Storybook**: Component documentation\n4. **CI/CD**: Automatic code quality checks\n\nClean code is a journey, not a destination. Every project is an opportunity to learn and improve. Start today - your code will be better tomorrow.\n\n---\n\n*This article was created during refactoring of a real application. All code examples are from a production project. Complete source code can be found in the attached [repository on github](https://github.com/hezky/example_dndKitIndexProblem.git).*"
}