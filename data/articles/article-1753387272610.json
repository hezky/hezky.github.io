{
  "id": "article-1753387272610",
  "title": "Proč nikdy nepoužívat indexy pole jako ID v @dnd-kit: Komplexní průvodce pro React vývojáře",
  "date": "2025-07-24",
  "description": "Používání indexů pole jako identifikátorů v knihovně @dnd-kit může vést k závažným chybám při přetahování, ztrátě interního stavu komponent, nesprávným animacím a výkonovým problémům. Tento článek vysvětluje, proč jsou stabilní ID klíčové pro správné fungování drag & drop logiky, jak @dnd-kit pracuje s identifikátory a nabízí správné techniky generování a správy ID. Vhodné pro všechny React vývojáře, kteří chtějí tvořit robustní a bezchybné uživatelské rozhraní.",
  "tags": [
    "React",
    "Javascript",
    "Frontend"
  ],
  "category": "framework",
  "markdown": "# Proč nikdy nepoužívat indexy pole jako ID v @dnd-kit: Komplexní průvodce pro React vývojáře\n\n## Úvod\n\nDrag and drop funkcionality se stala nezbytnou součástí moderních webových aplikací. Od přeorganizování položek seznamu po komplexní builderů rozhraní, uživatelé očekávají plynulé a intuitivní interakce. Knihovna @dnd-kit se etablovala jako jedno z nejvýkonnějších řešení pro implementaci drag and drop v React aplikacích. Avšak i s tak pokročilým nástrojem mohou vývojáři narazit na záludné problémy, pokud nedodržují osvědčené postupy – a jedním z nejčastějších je používání indexů pole jako identifikátorů.\n\nV tomto článku se podrobně podíváme na to, proč je používání indexů jako ID v @dnd-kit (a obecně v React aplikacích) považováno za anti-pattern, jaké konkrétní problémy to způsobuje a jak tyto problémy efektivně řešit.\n\n## Anatomie problému\n\n### Jak @dnd-kit pracuje s identifikátory\n\n@dnd-kit využívá systém unikátních identifikátorů k sledování jednotlivých přetahovatelných prvků. Když iniciujete drag operaci, knihovna:\n\n1. **Zaregistruje prvek** pomocí poskytnutého ID\n2. **Sleduje pozici** prvku během přetahování\n3. **Vypočítává kolize** s ostatními prvky\n4. **Aktualizuje pořadí** na základě těchto výpočtů\n\nIdentifikátor je tedy klíčovým prvkem, který umožňuje knihovně správně mapovat virtuální reprezentaci na skutečné DOM elementy.\n\n### Proč indexy selhávají\n\nPředstavme si jednoduchý seznam:\n\n```javascript\nconst items = ['Položka A', 'Položka B', 'Položka C', 'Položka D'];\n\n// ŠPATNĚ: Použití indexu jako ID\n<SortableContext items={items.map((_, index) => index)}>\n  {items.map((item, index) => (\n    <SortableItem key={index} id={index} value={item} />\n  ))}\n</SortableContext>\n```\n\nNa první pohled se může zdát, že tento přístup funguje. Problém nastává ve chvíli, kdy dojde k jakékoliv změně v poli:\n\n1. **Smazání položky**: Když smažete \"Položka B\" (index 1), všechny následující položky dostanou nové indexy:\n   - \"Položka C\" se přesune z indexu 2 na index 1\n   - \"Položka D\" se přesune z indexu 3 na index 2\n\n2. **@dnd-kit si pamatuje staré mapování**: Knihovna stále asociuje ID 2 s původní \"Položkou C\", ale na této pozici je nyní \"Položka D\"\n\n3. **Výsledek**: Při pokusu o přetažení se prvky chovají nepředvídatelně – přetahujete jiný prvek, než který jste uchopili.\n\n## Technické důsledky\n\n### 1. Nesprávná identifikace prvků\n\nKdyž @dnd-kit zpracovává drag událost, používá ID k určení, který prvek je přetahován:\n\n```javascript\nconst handleDragEnd = (event) => {\n  const { active, over } = event;\n  // active.id a over.id jsou indexy, které už neodpovídají správným prvkům!\n};\n```\n\n### 2. Problémy s React reconciliation\n\nReact používá klíče (keys) k optimalizaci vykreslování. Když použijete indexy:\n\n- React nemůže správně identifikovat, které komponenty se změnily\n- Stav komponent může být přiřazen nesprávným prvkům\n- Dochází k zbytečným re-renderům\n\n### 3. Ztráta interního stavu komponent\n\nPředstavte si, že každá položka má vlastní interní stav (například rozbalené/sbalené):\n\n```javascript\nfunction SortableItem({ id, value }) {\n  const [isExpanded, setIsExpanded] = useState(false);\n  // ...\n}\n```\n\nPři použití indexů jako klíčů může stav `isExpanded` zůstat asociován s pozicí, nikoliv s konkrétní položkou.\n\n### 4. Narušení animací\n\n@dnd-kit spoléhá na stabilní identifikátory pro plynulé animace. Když se ID mění, knihovna nemůže správně vypočítat transformace, což vede k trhavým nebo nesprávným animacím.\n\n## Demonstrace problému v praxi\n\nVytvořil jsem [interaktivní demo aplikaci](#), která názorně ukazuje rozdíl mezi použitím indexů a správných identifikátorů. V aplikaci můžete:\n\n1. **Porovnat tři přístupy**:\n   - ❌ Špatně: Použití indexů\n   - ✅ Řešení: Generování ID když nejsou k dispozici\n   - ✅ Správně: Použití stabilních ID z datového modelu\n\n2. **Vyzkoušet problematické scénáře**:\n   - Smazat položku uprostřed seznamu\n   - Pokusit se přetáhnout zbývající položky\n   - Sledovat, jak se chovají různé implementace\n\n3. **Vidět debug informace**:\n   - Aktuální ID každé položky\n   - Historie drag operací\n   - Varování při problematických operacích\n\n## Správná řešení\n\n### 1. Použití ID z datového modelu\n\nNejlepší řešení je mít unikátní identifikátory přímo v datech:\n\n```javascript\nconst items = [\n  { id: 'item-1', name: 'Položka A' },\n  { id: 'item-2', name: 'Položka B' },\n  { id: 'item-3', name: 'Položka C' },\n  { id: 'item-4', name: 'Položka D' }\n];\n\n<SortableContext items={items.map(item => item.id)}>\n  {items.map((item) => (\n    <SortableItem key={item.id} id={item.id} value={item.name} />\n  ))}\n</SortableContext>\n```\n\n### 2. Generování ID při načtení dat\n\nPokud data přicházejí bez ID (například z API), vygenerujte je při prvním zpracování:\n\n```javascript\n// Použití nanoid (doporučeno)\nimport { nanoid } from 'nanoid';\n\nconst processData = (rawData) => {\n  return rawData.map(item => ({\n    id: nanoid(8), // Generuje 8-znakové ID\n    ...item\n  }));\n};\n\n// Alternativa s crypto API\nconst generateId = () => {\n  if (crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  // Fallback pro starší prohlížeče\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n};\n```\n\n### 3. Použití kompozitních klíčů\n\nPro komplexnější datové struktury můžete vytvořit kompozitní klíče:\n\n```javascript\nconst generateCompositeId = (item) => {\n  return `${item.type}-${item.name}-${item.createdAt}`;\n};\n```\n\n### 4. Správná implementace drag handleru\n\n```javascript\nconst handleDragEnd = (event) => {\n  const { active, over } = event;\n  \n  if (active.id !== over.id) {\n    setItems((items) => {\n      // Najít indexy pomocí ID, ne použít ID jako indexy!\n      const oldIndex = items.findIndex(item => item.id === active.id);\n      const newIndex = items.findIndex(item => item.id === over.id);\n      \n      return arrayMove(items, oldIndex, newIndex);\n    });\n  }\n};\n```\n\n## Best practices pro @dnd-kit\n\n### 1. Nikdy nepoužívejte 0 jako ID\n\n@dnd-kit interně používá falsy hodnoty pro detekci. ID 0 způsobí, že prvek nebude možné přetáhnout:\n\n```javascript\n// ŠPATNĚ\nconst items = [0, 1, 2, 3];\n\n// SPRÁVNĚ\nconst items = ['1', '2', '3', '4'];\n// nebo\nconst items = [1, 2, 3, 4];\n```\n\n### 2. Udržujte konzistentní pořadí\n\nItems v `SortableContext` musí být ve stejném pořadí jako vykreslené komponenty:\n\n```javascript\n// Ujistěte se, že pořadí odpovídá\nconst sortedItems = [...items].sort((a, b) => a.order - b.order);\n\n<SortableContext items={sortedItems.map(item => item.id)}>\n  {sortedItems.map(item => (\n    <SortableItem key={item.id} id={item.id} {...item} />\n  ))}\n</SortableContext>\n```\n\n### 3. Optimalizace výkonu\n\nPro velké seznamy zvažte:\n\n```javascript\n// Memoizace ID seznamu\nconst itemIds = useMemo(\n  () => items.map(item => item.id),\n  [items]\n);\n\n// Použití virtualizace pro dlouhé seznamy\nimport { useVirtual } from '@tanstack/react-virtual';\n```\n\n### 4. Správné typování (TypeScript)\n\n```typescript\ninterface DraggableItem {\n  id: string; // Vždy string nebo number, nikdy undefined\n  content: string;\n  order: number;\n}\n\nconst items: DraggableItem[] = [\n  { id: 'item-1', content: 'První položka', order: 0 },\n  // ...\n];\n```\n\n## Časté chyby a jejich řešení\n\n### Chyba 1: Generování ID při každém renderu\n\n```javascript\n// ŠPATNĚ - ID se mění při každém renderu\n{items.map(item => (\n  <SortableItem key={Math.random()} id={Math.random()} />\n))}\n\n// SPRÁVNĚ - ID jsou stabilní\n{items.map(item => (\n  <SortableItem key={item.id} id={item.id} />\n))}\n```\n\n### Chyba 2: Míchání indexů a ID\n\n```javascript\n// ŠPATNĚ - key používá ID, ale id používá index\n{items.map((item, index) => (\n  <SortableItem key={item.id} id={index} />\n))}\n\n// SPRÁVNĚ - konzistentní použití\n{items.map(item => (\n  <SortableItem key={item.id} id={item.id} />\n))}\n```\n\n### Chyba 3: Zapomenutí na aktualizaci ID při klonování\n\n```javascript\n// ŠPATNĚ - klon má stejné ID\nconst duplicateItem = { ...originalItem };\n\n// SPRÁVNĚ - nové ID pro klon\nconst duplicateItem = { \n  ...originalItem, \n  id: generateNewId() \n};\n```\n\n## Výkonnostní dopady\n\nPoužívání správných identifikátorů má významný dopad na výkon:\n\n1. **Méně re-renderů**: React může efektivněji určit, které komponenty se skutečně změnily\n2. **Rychlejší reconciliation**: Stabilní klíče umožňují React optimalizovat DOM operace\n3. **Plynulejší animace**: @dnd-kit může předpočítat transformace\n4. **Menší memory footprint**: Není potřeba přepočítávat pozice při každé změně\n\n## Ladění a diagnostika\n\n### ESLint pravidla\n\nNastavte si ESLint pravidla pro prevenci:\n\n```json\n{\n  \"rules\": {\n    \"react/no-array-index-key\": \"error\",\n    \"react/jsx-key\": [\"error\", { \"checkFragmentShorthand\": true }]\n  }\n}\n```\n\n### Debug komponenta\n\n```javascript\nfunction DebugItem({ id, index }) {\n  useEffect(() => {\n    console.log(`Item ${id} is now at index ${index}`);\n  }, [index]);\n  \n  return (\n    <div>\n      ID: {id} | Index: {index}\n    </div>\n  );\n}\n```\n\n## Závěr\n\nPoužívání indexů pole jako identifikátorů v @dnd-kit je častou chybou, která může vést k nepředvídatelnému chování, výkonnostním problémům a frustraci uživatelů. Klíčem k úspěšné implementaci drag and drop funkcí je pochopení, proč stabilní identifikátory jsou nezbytné a jak je správně implementovat.\n\nHlavní poznatky:\n\n1. **Vždy používejte stabilní, unikátní identifikátory**\n2. **Generujte ID při vytvoření dat, ne při renderování**\n3. **Nikdy nepoužívejte index pole, Math.random() nebo jiné nestabilní hodnoty**\n4. **Testujte s operacemi přidávání a mazání položek**\n5. **Využijte TypeScript pro typovou bezpečnost**\n\nSprávná implementace identifikátorů je základem robustní a výkonné drag and drop funkcionality. S těmito znalostmi můžete vytvářet aplikace, které poskytují uživatelům plynulou a intuitivní zkušenost.\n\n---\n\n**Další zdroje:**\n\n- [@dnd-kit oficiální dokumentace](https://docs.dndkit.com)\n- [React dokumentace - Lists and Keys](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)\n- [Interaktivní demo aplikace](#) - odkaz bude doplněn\n\n*Autor: David Hezky | Publikováno: Červenec 2025*",
  "metadata": {
    "author": "David Hezky",
    "readingTime": "7 min"
  },
  "title.en": "Why you should never use array indices as IDs in @dnd-kit: A comprehensive guide for React developers",
  "description.en": "Using array indices as identifiers in the @dnd-kit library can lead to serious drag and drop errors, loss of internal component state, incorrect animations, and performance issues. This article explains why stable IDs are crucial for proper drag & drop logic, how @dnd-kit works with identifiers, and provides proper techniques for generating and managing IDs. Suitable for all React developers who want to create robust and error-free user interfaces.",
  "markdown.en": "# Why You Should Never Use Array Indexes as IDs in @dnd-kit: A Comprehensive Guide for React Developers\n\n## Introduction\n\nDrag and drop functionality has become an essential part of modern web applications. From reorganizing list items to complex interface builders, users expect smooth and intuitive interactions. The @dnd-kit library has established itself as one of the most performant solutions for implementing drag and drop in React applications. However, even with such an advanced tool, developers can encounter tricky problems if they don't follow best practices – and one of the most common is using array indexes as identifiers.\n\nIn this article, we'll take a detailed look at why using indexes as IDs in @dnd-kit (and React applications in general) is considered an anti-pattern, what specific problems it causes, and how to effectively solve these issues.\n\n## Anatomy of the Problem\n\n### How @dnd-kit Works with Identifiers\n\n@dnd-kit uses a system of unique identifiers to track individual draggable elements. When you initiate a drag operation, the library:\n\n1. **Registers the element** using the provided ID\n2. **Tracks the position** of the element during dragging\n3. **Calculates collisions** with other elements\n4. **Updates the order** based on these calculations\n\nThe identifier is therefore a key element that allows the library to correctly map the virtual representation to actual DOM elements.\n\n### Why Indexes Fail\n\nLet's imagine a simple list:\n\n```javascript\nconst items = ['Item A', 'Item B', 'Item C', 'Item D'];\n\n// WRONG: Using index as ID\n<SortableContext items={items.map((_, index) => index)}>\n  {items.map((item, index) => (\n    <SortableItem key={index} id={index} value={item} />\n  ))}\n</SortableContext>\n```\n\nAt first glance, this approach might seem to work. The problem occurs when any change happens to the array:\n\n1. **Deleting an item**: When you delete \"Item B\" (index 1), all subsequent items get new indexes:\n   - \"Item C\" moves from index 2 to index 1\n   - \"Item D\" moves from index 3 to index 2\n\n2. **@dnd-kit remembers the old mapping**: The library still associates ID 2 with the original \"Item C\", but \"Item D\" is now at this position\n\n3. **Result**: When attempting to drag, elements behave unpredictably – you're dragging a different element than the one you grabbed.\n\n## Technical Consequences\n\n### 1. Incorrect Element Identification\n\nWhen @dnd-kit processes a drag event, it uses the ID to determine which element is being dragged:\n\n```javascript\nconst handleDragEnd = (event) => {\n  const { active, over } = event;\n  // active.id and over.id are indexes that no longer correspond to the correct elements!\n};\n```\n\n### 2. React Reconciliation Issues\n\nReact uses keys to optimize rendering. When you use indexes:\n\n- React cannot correctly identify which components have changed\n- Component state may be assigned to wrong elements\n- Unnecessary re-renders occur\n\n### 3. Loss of Component Internal State\n\nImagine each item has its own internal state (for example, expanded/collapsed):\n\n```javascript\nfunction SortableItem({ id, value }) {\n  const [isExpanded, setIsExpanded] = useState(false);\n  // ...\n}\n```\n\nWhen using indexes as keys, the `isExpanded` state may remain associated with the position, not with the specific item.\n\n### 4. Animation Disruption\n\n@dnd-kit relies on stable identifiers for smooth animations. When IDs change, the library cannot correctly calculate transformations, leading to jerky or incorrect animations.\n\n## Practical Demonstration\n\nI've created an [interactive demo application](#) that clearly shows the difference between using indexes and proper identifiers. In the app, you can:\n\n1. **Compare three approaches**:\n   - ❌ Wrong: Using indexes\n   - ✅ Solution: Generating IDs when not available\n   - ✅ Correct: Using stable IDs from the data model\n\n2. **Try problematic scenarios**:\n   - Delete an item in the middle of the list\n   - Attempt to drag remaining items\n   - Observe how different implementations behave\n\n3. **See debug information**:\n   - Current ID of each item\n   - History of drag operations\n   - Warnings for problematic operations\n\n## Proper Solutions\n\n### 1. Using IDs from the Data Model\n\nThe best solution is to have unique identifiers directly in the data:\n\n```javascript\nconst items = [\n  { id: 'item-1', name: 'Item A' },\n  { id: 'item-2', name: 'Item B' },\n  { id: 'item-3', name: 'Item C' },\n  { id: 'item-4', name: 'Item D' }\n];\n\n<SortableContext items={items.map(item => item.id)}>\n  {items.map((item) => (\n    <SortableItem key={item.id} id={item.id} value={item.name} />\n  ))}\n</SortableContext>\n```\n\n### 2. Generating IDs When Loading Data\n\nIf data comes without IDs (for example, from an API), generate them during first processing:\n\n```javascript\n// Using nanoid (recommended)\nimport { nanoid } from 'nanoid';\n\nconst processData = (rawData) => {\n  return rawData.map(item => ({\n    id: nanoid(8), // Generates 8-character ID\n    ...item\n  }));\n};\n\n// Alternative with crypto API\nconst generateId = () => {\n  if (crypto.randomUUID) {\n    return crypto.randomUUID();\n  }\n  // Fallback for older browsers\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n};\n```\n\n### 3. Using Composite Keys\n\nFor more complex data structures, you can create composite keys:\n\n```javascript\nconst generateCompositeId = (item) => {\n  return `${item.type}-${item.name}-${item.createdAt}`;\n};\n```\n\n### 4. Proper Drag Handler Implementation\n\n```javascript\nconst handleDragEnd = (event) => {\n  const { active, over } = event;\n  \n  if (active.id !== over.id) {\n    setItems((items) => {\n      // Find indexes using IDs, don't use IDs as indexes!\n      const oldIndex = items.findIndex(item => item.id === active.id);\n      const newIndex = items.findIndex(item => item.id === over.id);\n      \n      return arrayMove(items, oldIndex, newIndex);\n    });\n  }\n};\n```\n\n## Best Practices for @dnd-kit\n\n### 1. Never Use 0 as an ID\n\n@dnd-kit internally uses falsy values for detection. ID 0 will cause the element to be undraggable:\n\n```javascript\n// WRONG\nconst items = [0, 1, 2, 3];\n\n// CORRECT\nconst items = ['1', '2', '3', '4'];\n// or\nconst items = [1, 2, 3, 4];\n```\n\n### 2. Maintain Consistent Order\n\nItems in `SortableContext` must be in the same order as rendered components:\n\n```javascript\n// Ensure the order matches\nconst sortedItems = [...items].sort((a, b) => a.order - b.order);\n\n<SortableContext items={sortedItems.map(item => item.id)}>\n  {sortedItems.map(item => (\n    <SortableItem key={item.id} id={item.id} {...item} />\n  ))}\n</SortableContext>\n```\n\n### 3. Performance Optimization\n\nFor large lists, consider:\n\n```javascript\n// Memoizing ID list\nconst itemIds = useMemo(\n  () => items.map(item => item.id),\n  [items]\n);\n\n// Using virtualization for long lists\nimport { useVirtual } from '@tanstack/react-virtual';\n```\n\n### 4. Proper Typing (TypeScript)\n\n```typescript\ninterface DraggableItem {\n  id: string; // Always string or number, never undefined\n  content: string;\n  order: number;\n}\n\nconst items: DraggableItem[] = [\n  { id: 'item-1', content: 'First item', order: 0 },\n  // ...\n];\n```\n\n## Common Mistakes and Their Solutions\n\n### Mistake 1: Generating IDs on Every Render\n\n```javascript\n// WRONG - IDs change on every render\n{items.map(item => (\n  <SortableItem key={Math.random()} id={Math.random()} />\n))}\n\n// CORRECT - IDs are stable\n{items.map(item => (\n  <SortableItem key={item.id} id={item.id} />\n))}\n```\n\n### Mistake 2: Mixing Indexes and IDs\n\n```javascript\n// WRONG - key uses ID but id uses index\n{items.map((item, index) => (\n  <SortableItem key={item.id} id={index} />\n))}\n\n// CORRECT - consistent usage\n{items.map(item => (\n  <SortableItem key={item.id} id={item.id} />\n))}\n```\n\n### Mistake 3: Forgetting to Update IDs When Cloning\n\n```javascript\n// WRONG - clone has the same ID\nconst duplicateItem = { ...originalItem };\n\n// CORRECT - new ID for clone\nconst duplicateItem = { \n  ...originalItem, \n  id: generateNewId() \n};\n```\n\n## Performance Impact\n\nUsing proper identifiers has a significant impact on performance:\n\n1. **Fewer re-renders**: React can more efficiently determine which components actually changed\n2. **Faster reconciliation**: Stable keys allow React to optimize DOM operations\n3. **Smoother animations**: @dnd-kit can pre-calculate transformations\n4. **Smaller memory footprint**: No need to recalculate positions on every change\n\n## Debugging and Diagnostics\n\n### ESLint Rules\n\nSet up ESLint rules for prevention:\n\n```json\n{\n  \"rules\": {\n    \"react/no-array-index-key\": \"error\",\n    \"react/jsx-key\": [\"error\", { \"checkFragmentShorthand\": true }]\n  }\n}\n```\n\n### Debug Component\n\n```javascript\nfunction DebugItem({ id, index }) {\n  useEffect(() => {\n    console.log(`Item ${id} is now at index ${index}`);\n  }, [index]);\n  \n  return (\n    <div>\n      ID: {id} | Index: {index}\n    </div>\n  );\n}\n```\n\n## Conclusion\n\nUsing array indexes as identifiers in @dnd-kit is a common mistake that can lead to unpredictable behavior, performance issues, and user frustration. The key to successful drag and drop implementation is understanding why stable identifiers are necessary and how to implement them correctly.\n\nKey takeaways:\n\n1. **Always use stable, unique identifiers**\n2. **Generate IDs when creating data, not during rendering**\n3. **Never use array index, Math.random(), or other unstable values**\n4. **Test with item addition and deletion operations**\n5. **Leverage TypeScript for type safety**\n\nProper identifier implementation is the foundation of robust and performant drag and drop functionality. With this knowledge, you can create applications that provide users with a smooth and intuitive experience.\n\n---\n\n**Additional Resources:**\n\n- [@dnd-kit official documentation](https://docs.dndkit.com)\n- [React documentation - Lists and Keys](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)\n- [Interactive demo application](#) - link to be added\n\n*Author: [Your Name] | Published: January 2025*"
}