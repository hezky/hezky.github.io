{
  "title": "XML Viewer SPA",
  "description": "Moderní přístup k zobrazování XML dat v React aplikacích",
  "markdown": "# XML Viewer SPA: Moderní přístup k zobrazování XML dat v React aplikacích\n\n## Úvod\n\nV éře webových aplikací se často setkáváme s potřebou zobrazit, validovat a manipulovat XML data přímo v prohlížeči. XML (eXtensible Markup Language) zůstává jedním z klíčových formátů pro výměnu dat mezi systémy, API komunikaci a konfigurační soubory. Tento článek představuje komplexní řešení pro zobrazování XML dat prostřednictvím Single Page Application (SPA) postavené na React frameworku s využitím moderních technologií.\n\nNáš XML Viewer implementuje dva odlišné přístupy k zobrazení XML dat: otevření v novém tabu prohlížeče s využitím vestavěného XML parseru a zobrazení přímo v aplikaci s možností syntax highlighting. Tento duální přístup poskytuje uživatelům flexibilitu při práci s XML dokumenty různých velikostí a složitostí.\n\n## Architektura a technologické rozhodnutí\n\n### Výběr technologického stacku\n\nPro implementaci XML Viewer SPA jsme zvolili následující technologie:\n\n**React 18** jako hlavní framework pro jeho zralost, rozsáhlý ekosystém a výkonný concurrent rendering. React 18 přináší významná vylepšení v oblasti automatického batch zpracování stavových aktualizací a suspense funkcionalitu, což je klíčové pro responzivní uživatelské rozhraní.\n\n**Vite** jako build tool a dev server nahrazuje tradičně používaný Create React App díky výrazně rychlejšímu hot module replacement (HMR) a optimalizovanému bundlingu pomocí Rollup. Vite využívá native ES modules během vývoje, což dramaticky snižuje čas spuštění aplikace.\n\n**Highlight.js** pro syntax highlighting XML kódu poskytuje robustní a výkonnou implementaci s podporou více než 190 programovacích jazyků včetně XML/HTML. Knihovna je optimalizována pro bundle size a umožňuje tree-shaking pro import pouze potřebných jazyků.\n\n**XML-formatter** je specializovaná knihovna pro profesionální formátování XML dokumentů. Nabízí pokročilé možnosti konfigurace, lepší handling edge cases a optimalizovaný výkon pro velké XML soubory. Knihovna podporuje filtrování uzlů, konfigurovatelné odsazení a různé výstupní formáty.\n\n**Lucide React** pro ikony nabízí moderní, konzistentní sadu SVG ikon s TypeScript podporou a malou velikostí bundle. Ikony jsou optimalizované pro tree-shaking a podporují customizaci prostřednictvím CSS.\n\n### Komponentová architektura\n\nAplikace následuje principy modulární architektury s jasnými zodpovědnostmi komponent:\n\n```\nsrc/\n├── components/\n│   ├── XmlInput/           # Vstupní komponenta pro XML data\n│   ├── XmlViewerBasic/     # Základní zobrazení v pre elementu\n│   ├── XmlViewerHighlight/ # Pokročilé zobrazení s syntax highlighting\n│   └── ViewerControls/     # Ovládací panel s akcemi\n├── utils/\n│   └── xmlUtils.js         # Utility funkce pro XML manipulaci\n└── styles/\n    └── globals.css         # Globální styly a CSS custom properties\n```\n\n### Design patterns a best practices\n\n**Container/Presenter pattern**: Hlavní App komponenta slouží jako container, který spravuje stav a business logiku, zatímco jednotlivé komponenty jsou prezentační a zaměřují se pouze na UI rendering.\n\n**Single Responsibility Principle**: Každá komponenta má jednu jasně definovanou zodpovědnost - XmlInput pro vstup dat, ViewerControls pro akce, XmlViewer komponenty pro zobrazení.\n\n**Composition over Inheritance**: Komponenty jsou komponovány prostřednictvím props a children, což umožňuje flexibilní reuse a testování.\n\n## Implementace klíčových funkcionalít\n\n### XML Input a File Handling\n\nKomponenta `XmlInput` implementuje několik způsobů načítání XML dat:\n\n1. **Manual input**: Textarea s real-time validací\n2. **File upload**: Standardní file input s filtrem na XML soubory\n3. **Drag & Drop**: Moderní přístup s visual feedback\n\n```javascript\nconst handleDrop = (event) => {\n  event.preventDefault();\n  event.stopPropagation();\n\n  const files = event.dataTransfer.files;\n  if (files.length > 0) {\n    const file = files[0];\n    if (file.type === 'text/xml' || file.name.endsWith('.xml')) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        if (onFileLoad) {\n          onFileLoad(e.target.result);\n        }\n      };\n      reader.readAsText(file);\n    }\n  }\n};\n```\n\nImplementace využívá FileReader API pro asynchronní načítání souborů s proper error handling. Validace typu souboru probíhá na úrovni MIME type i file extension pro maximální kompatibilitu napříč prohlížeči.\n\n### XML Validace a Parsing\n\nValidace XML využívá DOMParser API, které je nativně dostupné ve všech moderních prohlížečích:\n\n```javascript\nexport function validateXml(xmlString) {\n  if (!xmlString || xmlString.trim() === '') {\n    return { isValid: false, error: 'XML content is empty' };\n  }\n\n  try {\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlString, \"application/xml\");\n    const parseError = xmlDoc.getElementsByTagName(\"parsererror\");\n\n    if (parseError.length > 0) {\n      return {\n        isValid: false,\n        error: parseError[0].textContent || 'Invalid XML format'\n      };\n    }\n\n    return { isValid: true, error: null };\n  } catch (error) {\n    return {\n      isValid: false,\n      error: `XML validation error: ${error.message}`\n    };\n  }\n}\n```\n\nDOMParser poskytuje robustní validaci s detailními chybovými hlášeními. Při chybě parsingu vytváří `parsererror` element s popisem problému, což umožňuje poskytovat uživateli specifické feedback o syntax chybách.\n\n### Otevření XML v novém tabu\n\nJedna z klíčových funkcionalností aplikace je možnost otevřít XML v novém tabu prohlížeče s využitím vestavěného XML vieweru:\n\n```javascript\nexport function openXmlInNewTab(xmlString) {\n  const blob = new Blob([xmlString], { type: \"application/xml\" });\n  const url = URL.createObjectURL(blob);\n  window.open(url, \"_blank\");\n  // Cleanup URL object after some delay\n  setTimeout(() => URL.revokeObjectURL(url), 1000);\n}\n```\n\nTento přístup využívá Blob API pro vytvoření dočasného URL objektu s MIME typem `application/xml`. Prohlížeč automaticky rozpozná formát a použije vestavěný XML viewer s features jako je tree structure, syntax highlighting a možnost collapse/expand elementů.\n\nCleanup pomocí `URL.revokeObjectURL()` je kritický pro předcházení memory leaks, zejména při opakovaném používání funkce. Timeout zajišťuje, že URL zůstane validní dostatečně dlouho pro načtení v novém tabu.\n\n### Syntax Highlighting implementace\n\nPro in-app zobrazení XML s syntax highlighting používáme highlight.js:\n\n```javascript\nimport hljs from 'highlight.js/lib/core';\nimport xml from 'highlight.js/lib/languages/xml';\nimport 'highlight.js/styles/github-dark.css';\n\n// Register XML language\nhljs.registerLanguage('xml', xml);\n\nconst XmlViewerHighlight = ({ xmlContent }) => {\n  const codeRef = useRef(null);\n\n  useEffect(() => {\n    if (codeRef.current && xmlContent) {\n      hljs.highlightElement(codeRef.current);\n    }\n  }, [xmlContent]);\n\n  return (\n    <pre className=\"xml-viewer-highlight__content\">\n      <code ref={codeRef} className=\"language-xml\">\n        {xmlContent}\n      </code>\n    </pre>\n  );\n};\n```\n\nImplementace využívá selective import z highlight.js pro minimalizaci bundle size. Registrace pouze XML jazyka snižuje velikost finálního bundle o značnou část. useEffect hook zajišťuje re-highlighting při změně obsahu.\n\n### XML Formátování (Pretty Print)\n\nAplikace implementuje dva přístupy k formátování XML:\n\n#### 1. Vlastní implementace pomocí DOMParser a XMLSerializer\n\n```javascript\nexport function formatXml(xmlString) {\n  try {\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlString, \"application/xml\");\n\n    if (xmlDoc.getElementsByTagName(\"parsererror\").length > 0) {\n      return xmlString; // Return original if parsing fails\n    }\n\n    const serializer = new XMLSerializer();\n    let formatted = serializer.serializeToString(xmlDoc);\n\n    // Simple formatting with indentation\n    formatted = formatted.replace(/></g, '>\\n<');\n    const lines = formatted.split('\\n');\n    let indentLevel = 0;\n    const indentString = '  ';\n\n    return lines.map(line => {\n      const trimmed = line.trim();\n      if (trimmed === '') return '';\n\n      if (trimmed.startsWith('</')) {\n        indentLevel = Math.max(0, indentLevel - 1);\n      }\n\n      const result = indentString.repeat(indentLevel) + trimmed;\n\n      if (trimmed.startsWith('<') && !trimmed.startsWith('</') && !trimmed.endsWith('/>')) {\n        indentLevel++;\n      }\n\n      return result;\n    }).join('\\n');\n  } catch (error) {\n    console.error('XML formatting error:', error);\n    return xmlString;\n  }\n}\n```\n\nAlgoritmus analyzuje XML strukturu a aplikuje konzistentní odsazení na základě nesting level. Self-closing tagy jsou korektně rozpoznány a neovlivňují indentation level.\n\n#### 2. Profesionální formátování pomocí xml-formatter knihovny\n\nPro pokročilejší případy použití implementujeme také formátování pomocí specializované knihovny:\n\n```javascript\nimport xmlFormatter from 'xml-formatter';\n\nexport function formatXmlWithLibrary(xmlString) {\n  try {\n    const validation = validateXml(xmlString);\n    if (!validation.isValid) {\n      return xmlString;\n    }\n\n    return xmlFormatter(xmlString, {\n      indentation: '  ',\n      filter: (node) => node.type !== 'Comment',\n      collapseContent: true,\n      lineSeparator: '\\n'\n    });\n  } catch (error) {\n    console.error('XML formatting error (library):', error);\n    return xmlString;\n  }\n}\n```\n\n**Výhody xml-formatter knihovny:**\n\n- **Robustní parsing**: Lepší zvládání edge cases a komplexních XML struktur\n- **Pokročilé možnosti**: Filtrování uzlů, konfigurovatelné odsazení, handling komentářů\n- **Performance**: Optimalizováno pro velké XML dokumenty\n- **Standardizace**: Široce používaná knihovna s konzistentními výsledky\n- **Flexibilita**: Možnost customizace výstupního formátu podle potřeb\n\nUživatelé mají k dispozici obě možnosti - základní formátování pro rychlé použití a pokročilé pro komplexnější XML dokumenty.\n\n## Styling a UI/UX design\n\n### CSS Architektura\n\nProjekt využívá BEM (Block Element Modifier) metodiku pro organizaci CSS:\n\n```css\n.xml-viewer-highlight {\n  background: #2C2C2C;\n  border-radius: 8px;\n  padding: 1.5rem;\n}\n\n.xml-viewer-highlight__header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.xml-viewer-highlight__copy-button {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.xml-viewer-highlight__copy-button--active {\n  background: #F7464E;\n  color: #F7F8F3;\n}\n```\n\nBEM poskytuje jasnou konvenci pro naming a předchází CSS konflikty. Modular approach umožňuje easy maintenance a refactoring.\n\n### Dark Mode téma\n\nAplikace implementuje dark mode jako primární téma s použitím CSS custom properties:\n\n```css\n:root {\n  --primary-bg: #1A1A1A;\n  --secondary-bg: #2C2C2C;\n  --card-bg: #333333;\n  --text-primary: #F7F8F3;\n  --text-secondary: #999;\n  --accent-teal: #78BCC4;\n  --accent-crimson: #F7464E;\n}\n\nbody {\n  background-color: var(--primary-bg);\n  color: var(--text-primary);\n}\n```\n\nCustom properties umožňují snadné theme switching v budoucnu a konzistentní color palette napříč aplikací.\n\n### Responzivní design\n\nImplementace mobile-first přístupu s progressive enhancement:\n\n```css\n/* Mobile first */\n.viewer-controls__grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 0.75rem;\n}\n\n/* Tablet */\n@media (min-width: 768px) {\n  .viewer-controls__grid {\n    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));\n    gap: 1rem;\n  }\n}\n\n/* Desktop */\n@media (min-width: 1024px) {\n  .viewer-controls__grid {\n    gap: 1.5rem;\n  }\n}\n```\n\nCSS Grid poskytuje flexibilní layout s automatickým flow pro různé screen sizes. Auto-fit a minmax zajišťují optimální využití dostupného prostoru.\n\n## Performance optimalizace\n\n### Bundle Size optimalizace\n\nSelective imports z knihoven minimalizují bundle size:\n\n```javascript\n// Místo celé knihovny\nimport hljs from 'highlight.js';\n\n// Importujeme pouze potřebné části\nimport hljs from 'highlight.js/lib/core';\nimport xml from 'highlight.js/lib/languages/xml';\n```\n\nTento přístup snižuje bundle size highlight.js z ~500KB na ~50KB.\n\n### Lazy Loading a Code Splitting\n\nPro budoucí rozšíření aplikace je připravena infrastruktura pro lazy loading:\n\n```javascript\n// Potenciální lazy loading pro large XML viewers\nconst XmlViewerAdvanced = lazy(() => import('./XmlViewerAdvanced'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      {showAdvanced && <XmlViewerAdvanced />}\n    </Suspense>\n  );\n}\n```\n\n### Memory Management\n\nProper cleanup pro file readers a blob URLs:\n\n```javascript\nconst handleFileChange = (event) => {\n  const file = event.target.files[0];\n  if (file) {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      // Process file content\n      onFileLoad(e.target.result);\n    };\n    reader.onerror = (error) => {\n      console.error('File reading error:', error);\n    };\n    reader.readAsText(file);\n  }\n};\n```\n\nExplicit error handling pro FileReader předchází memory leaks při čtení velkých souborů.\n\n## Error Handling a Edge Cases\n\n### Graceful Error Handling\n\nAplikace implementuje comprehensive error handling:\n\n```javascript\nconst [validationError, setValidationError] = useState(null);\n\nconst handleXmlChange = (content) => {\n  setXmlContent(content);\n  setValidationError(null);\n\n  if (content.trim()) {\n    const validation = validateXml(content);\n    if (!validation.isValid) {\n      setValidationError(validation.error);\n    }\n  }\n};\n```\n\nReal-time validace poskytuje immediate feedback bez nutnosti explicitní submise.\n\n### Large File Handling\n\nPro velké XML soubory implementujeme postupné načítání:\n\n```javascript\nconst handleLargeFile = (file) => {\n  if (file.size > 5 * 1024 * 1024) { // 5MB limit\n    alert('File is too large. Please use a smaller XML file.');\n    return;\n  }\n\n  // Process normally\n  processFile(file);\n};\n```\n\nSize limit předchází browser freeze při načítání extrémně velkých XML dokumentů.\n\n### Cross-browser Compatibility\n\nAplikace testuje support pro klíčové APIs:\n\n```javascript\nconst checkBrowserSupport = () => {\n  if (!window.DOMParser) {\n    console.warn('DOMParser not supported');\n    return false;\n  }\n\n  if (!window.XMLSerializer) {\n    console.warn('XMLSerializer not supported');\n    return false;\n  }\n\n  return true;\n};\n```\n\n## Accessibility (A11Y) implementace\n\n### Keyboard Navigation\n\nVšechny interaktivní elementy podporují keyboard navigation:\n\n```css\n.viewer-controls__button:focus {\n  outline: 2px solid var(--accent-teal);\n  outline-offset: 2px;\n}\n\n.xml-input__textarea:focus {\n  border-color: var(--accent-teal);\n  box-shadow: 0 0 0 2px rgba(120, 188, 196, 0.2);\n}\n```\n\n### Screen Reader Support\n\nSemantic HTML a ARIA labels pro screen readers:\n\n```jsx\n<button\n  className=\"xml-viewer-basic__copy-button\"\n  onClick={handleCopy}\n  aria-label=\"Copy XML content to clipboard\"\n  title=\"Copy to clipboard\"\n>\n  {copied ? 'Copied!' : 'Copy'}\n</button>\n```\n\n### Color Contrast\n\nVšechny color combinations splňují WCAG 2.1 AA requirements s kontrastním poměrem minimálně 4.5:1.\n\n## Testing strategie\n\n### Unit Testing\n\nPro kritické utility funkce:\n\n```javascript\ndescribe('xmlUtils', () => {\n  test('validateXml returns true for valid XML', () => {\n    const validXml = '<?xml version=\"1.0\"?><root><child>content</child></root>';\n    const result = validateXml(validXml);\n    expect(result.isValid).toBe(true);\n  });\n\n  test('validateXml returns error for invalid XML', () => {\n    const invalidXml = '<root><child>unclosed';\n    const result = validateXml(invalidXml);\n    expect(result.isValid).toBe(false);\n    expect(result.error).toContain('error');\n  });\n});\n```\n\n### Integration Testing\n\nTesting user workflows s React Testing Library:\n\n```javascript\ntest('user can load sample XML and view it', async () => {\n  render(<App />);\n\n  const loadSampleButton = screen.getByText('Load Sample');\n  fireEvent.click(loadSampleButton);\n\n  const showBasicButton = screen.getByText('Show Basic');\n  fireEvent.click(showBasicButton);\n\n  expect(screen.getByText(/catalog/)).toBeInTheDocument();\n});\n```\n\n### E2E Testing\n\nCypress testy pro complete user journeys:\n\n```javascript\ndescribe('XML Viewer E2E', () => {\n  it('should handle complete XML workflow', () => {\n    cy.visit('/');\n    cy.get('[data-testid=\"load-sample\"]').click();\n    cy.get('[data-testid=\"open-new-tab\"]').click();\n    cy.get('[data-testid=\"show-highlighted\"]').click();\n    cy.get('.xml-viewer-highlight').should('be.visible');\n  });\n});\n```\n\n## Security considerations\n\n### XSS Prevention\n\nVšechen user input je properly sanitized:\n\n```javascript\nconst sanitizeXml = (xmlString) => {\n  // Remove potential script tags and dangerous content\n  return xmlString.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n};\n```\n\n### File Upload Security\n\nValidation file types a size limits:\n\n```javascript\nconst isValidXmlFile = (file) => {\n  const allowedTypes = ['text/xml', 'application/xml'];\n  const allowedExtensions = ['.xml'];\n\n  return allowedTypes.includes(file.type) ||\n         allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));\n};\n```\n\n### CSP Headers\n\nContent Security Policy pro production deployment:\n\n```\nContent-Security-Policy: default-src 'self';\nscript-src 'self' 'unsafe-inline';\nstyle-src 'self' 'unsafe-inline';\nimg-src 'self' data: blob:;\n```\n\n## Production deployment\n\n### Build optimalizace\n\nVite build optimalizace pro production:\n\n```javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          vendor: ['react', 'react-dom'],\n          highlight: ['highlight.js']\n        }\n      }\n    }\n  }\n});\n```\n\n### Progressive Web App features\n\nService Worker pro offline support:\n\n```javascript\n// Budoucí implementace\nconst CACHE_NAME = 'xml-viewer-v1';\nconst urlsToCache = [\n  '/',\n  '/static/js/bundle.js',\n  '/static/css/main.css'\n];\n\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) => cache.addAll(urlsToCache))\n  );\n});\n```\n\n## Budoucí rozšíření\n\n### Plánované features\n\n1. **XML Schema Validation**: Implementace XSD validace\n2. **XSLT Transformation**: Support pro XML transformace\n3. **Diff Viewer**: Porovnání dvou XML dokumentů\n4. **XML to JSON Converter**: Bidirectional konverze\n5. **Collaborative Editing**: Real-time collaboration\n6. **Cloud Storage Integration**: Google Drive, Dropbox sync\n\n### Technologické vylepšení\n\n1. **TypeScript Migration**: Type safety a better DX\n2. **React 19 Concurrent Features**: Server Components\n3. **WebAssembly Integration**: Faster XML parsing\n4. **IndexedDB Storage**: Offline XML library\n5. **Web Workers**: Background XML processing\n\n## Závěr\n\nXML Viewer SPA představuje moderní přístup k práci s XML dokumenty v web environment. Aplikace úspěšně kombinuje simplicitu použití s pokročilými features a demonstruje best practices pro React aplikace v roce 2024.\n\nKlíčové úspěchy projektu:\n\n1. **User Experience**: Intuitivní interface s immediate feedback\n2. **Performance**: Optimalizovaný bundle size a rychlé loading\n3. **Accessibility**: WCAG 2.1 compliance a keyboard navigation\n4. **Maintainability**: Čistá architektura s jasným separation of concerns\n5. **Extensibility**: Modulární design připravený pro budoucí rozšíření\n\nProjekt demonstruje, jak moderní web technologie umožňují vytvářet robustní aplikace pro specialized use cases jako je XML processing. Kombinace React 18, Vite, highlight.js a xml-formatter poskytuje solid foundation pro complex XML workflows.\n\nPro vývojáře zajímající se o podobné projekty doporučujeme zaměřit se na proper error handling, accessibility a performance optimization od začátku vývoje. Tyto aspekty jsou často podceňované, ale kritické pro production-ready aplikace.\n\nKompletní source code je dostupný na GitHub s MIT licencí, což umožňuje free usage i pro komerční projekty. Budeme rádi za community contributions a feedback pro further improvements.\n\n---\n\nAutor: David Hezký\nDatum: Září 2025\nTechnologie: React 18, Vite, Highlight.js, XML-formatter\nLicence: MIT*",
  "tags": [
    "React",
    "Javascript",
    "Frontend"
  ],
  "category": "tutorial, technologie",
  "metadata": {
    "readingTime": "5 min"
  },
  "id": "article-1758728557231",
  "date": "2025-09-24",
  "filename": "articles/article-1758728557231.json",
  "title.en": "XML Viewer SPA",
  "description.en": "Modern Approach to Displaying XML Data in React Applications",
  "tags.en": [
    "React",
    "Javascript",
    "Frontend"
  ],
  "category.en": "tutorial, technology",
  "markdown.en": "# XML Viewer SPA: Modern Approach to Displaying XML Data in React Applications\n\n## Introduction\n\nIn the era of web applications, we frequently encounter the need to display, validate, and manipulate XML data directly in the browser. XML (eXtensible Markup Language) remains one of the key formats for data exchange between systems, API communication, and configuration files. This article presents a comprehensive solution for displaying XML data through a Single Page Application (SPA) built on the React framework using modern technologies.\n\nOur XML Viewer implements two distinct approaches to displaying XML data: opening in a new browser tab utilizing the built-in XML parser and displaying directly in the application with syntax highlighting capabilities. This dual approach provides users with flexibility when working with XML documents of various sizes and complexity.\n\n## Architecture and Technology Decisions\n\n### Technology Stack Selection\n\nFor the XML Viewer SPA implementation, we chose the following technologies:\n\n**React 18** as the main framework for its maturity, extensive ecosystem, and performant concurrent rendering. React 18 brings significant improvements in automatic batching of state updates and suspense functionality, which is crucial for responsive user interfaces.\n\n**Vite** as build tool and dev server replaces traditionally used Create React App due to significantly faster hot module replacement (HMR) and optimized bundling using Rollup. Vite leverages native ES modules during development, dramatically reducing application startup time.\n\n**Highlight.js** for XML code syntax highlighting provides robust and performant implementation with support for over 190 programming languages including XML/HTML. The library is optimized for bundle size and enables tree-shaking for importing only necessary languages.\n\n**XML-formatter** is a specialized library for professional XML document formatting. It offers advanced configuration options, better handling of edge cases, and optimized performance for large XML files. The library supports node filtering, configurable indentation, and various output formats.\n\n**Lucide React** for icons offers a modern, consistent set of SVG icons with TypeScript support and small bundle size. Icons are optimized for tree-shaking and support customization through CSS.\n\n### Component Architecture\n\nThe application follows modular architecture principles with clear component responsibilities:\n\n```\nsrc/\n├── components/\n│   ├── XmlInput/           # Input component for XML data\n│   ├── XmlViewerBasic/     # Basic display in pre element\n│   ├── XmlViewerHighlight/ # Advanced display with syntax highlighting\n│   └── ViewerControls/     # Control panel with actions\n├── utils/\n│   └── xmlUtils.js         # Utility functions for XML manipulation\n└── styles/\n    └── globals.css         # Global styles and CSS custom properties\n```\n\n### Design Patterns and Best Practices\n\n**Container/Presenter Pattern**: The main App component serves as a container managing state and business logic, while individual components are presentational and focus solely on UI rendering.\n\n**Single Responsibility Principle**: Each component has one clearly defined responsibility - XmlInput for data input, ViewerControls for actions, XmlViewer components for display.\n\n**Composition over Inheritance**: Components are composed through props and children, enabling flexible reuse and testing.\n\n## Implementation of Key Functionalities\n\n### XML Input and File Handling\n\nThe `XmlInput` component implements several ways to load XML data:\n\n1. **Manual input**: Textarea with real-time validation\n2. **File upload**: Standard file input with XML file filter\n3. **Drag & Drop**: Modern approach with visual feedback\n\n```javascript\nconst handleDrop = (event) => {\n  event.preventDefault();\n  event.stopPropagation();\n\n  const files = event.dataTransfer.files;\n  if (files.length > 0) {\n    const file = files[0];\n    if (file.type === 'text/xml' || file.name.endsWith('.xml')) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        if (onFileLoad) {\n          onFileLoad(e.target.result);\n        }\n      };\n      reader.readAsText(file);\n    }\n  }\n};\n```\n\nThe implementation utilizes FileReader API for asynchronous file loading with proper error handling. File type validation occurs at both MIME type and file extension levels for maximum compatibility across browsers.\n\n### XML Validation and Parsing\n\nXML validation utilizes DOMParser API, which is natively available in all modern browsers:\n\n```javascript\nexport function validateXml(xmlString) {\n  if (!xmlString || xmlString.trim() === '') {\n    return { isValid: false, error: 'XML content is empty' };\n  }\n\n  try {\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlString, \"application/xml\");\n    const parseError = xmlDoc.getElementsByTagName(\"parsererror\");\n\n    if (parseError.length > 0) {\n      return {\n        isValid: false,\n        error: parseError[0].textContent || 'Invalid XML format'\n      };\n    }\n\n    return { isValid: true, error: null };\n  } catch (error) {\n    return {\n      isValid: false,\n      error: `XML validation error: ${error.message}`\n    };\n  }\n}\n```\n\nDOMParser provides robust validation with detailed error messages. Upon parsing errors, it creates a `parsererror` element with problem description, enabling specific user feedback about syntax errors.\n\n### Opening XML in New Tab\n\nOne of the key functionalities is the ability to open XML in a new browser tab utilizing the built-in XML viewer:\n\n```javascript\nexport function openXmlInNewTab(xmlString) {\n  const blob = new Blob([xmlString], { type: \"application/xml\" });\n  const url = URL.createObjectURL(blob);\n  window.open(url, \"_blank\");\n  // Cleanup URL object after some delay\n  setTimeout(() => URL.revokeObjectURL(url), 1000);\n}\n```\n\nThis approach uses Blob API to create a temporary URL object with MIME type `application/xml`. The browser automatically recognizes the format and uses the built-in XML viewer with features like tree structure, syntax highlighting, and collapse/expand elements capability.\n\nCleanup using `URL.revokeObjectURL()` is critical for preventing memory leaks, especially with repeated function usage. The timeout ensures the URL remains valid long enough for loading in the new tab.\n\n### Syntax Highlighting Implementation\n\nFor in-app XML display with syntax highlighting, we use highlight.js:\n\n```javascript\nimport hljs from 'highlight.js/lib/core';\nimport xml from 'highlight.js/lib/languages/xml';\nimport 'highlight.js/styles/github-dark.css';\n\n// Register XML language\nhljs.registerLanguage('xml', xml);\n\nconst XmlViewerHighlight = ({ xmlContent }) => {\n  const codeRef = useRef(null);\n\n  useEffect(() => {\n    if (codeRef.current && xmlContent) {\n      hljs.highlightElement(codeRef.current);\n    }\n  }, [xmlContent]);\n\n  return (\n    <pre className=\"xml-viewer-highlight__content\">\n      <code ref={codeRef} className=\"language-xml\">\n        {xmlContent}\n      </code>\n    </pre>\n  );\n};\n```\n\nThe implementation uses selective import from highlight.js to minimize bundle size. Registering only the XML language reduces the final bundle size significantly. The useEffect hook ensures re-highlighting when content changes.\n\n### XML Formatting (Pretty Print)\n\nThe application implements two approaches to XML formatting:\n\n#### 1. Custom implementation using DOMParser and XMLSerializer\n\n```javascript\nexport function formatXml(xmlString) {\n  try {\n    const parser = new DOMParser();\n    const xmlDoc = parser.parseFromString(xmlString, \"application/xml\");\n\n    if (xmlDoc.getElementsByTagName(\"parsererror\").length > 0) {\n      return xmlString; // Return original if parsing fails\n    }\n\n    const serializer = new XMLSerializer();\n    let formatted = serializer.serializeToString(xmlDoc);\n\n    // Simple formatting with indentation\n    formatted = formatted.replace(/></g, '>\\n<');\n    const lines = formatted.split('\\n');\n    let indentLevel = 0;\n    const indentString = '  ';\n\n    return lines.map(line => {\n      const trimmed = line.trim();\n      if (trimmed === '') return '';\n\n      if (trimmed.startsWith('</')) {\n        indentLevel = Math.max(0, indentLevel - 1);\n      }\n\n      const result = indentString.repeat(indentLevel) + trimmed;\n\n      if (trimmed.startsWith('<') && !trimmed.startsWith('</') && !trimmed.endsWith('/>')) {\n        indentLevel++;\n      }\n\n      return result;\n    }).join('\\n');\n  } catch (error) {\n    console.error('XML formatting error:', error);\n    return xmlString;\n  }\n}\n```\n\nThe algorithm analyzes XML structure and applies consistent indentation based on nesting level. Self-closing tags are correctly recognized and don't affect the indentation level.\n\n#### 2. Professional formatting using xml-formatter library\n\nFor more advanced use cases, we also implement formatting using a specialized library:\n\n```javascript\nimport xmlFormatter from 'xml-formatter';\n\nexport function formatXmlWithLibrary(xmlString) {\n  try {\n    const validation = validateXml(xmlString);\n    if (!validation.isValid) {\n      return xmlString;\n    }\n\n    return xmlFormatter(xmlString, {\n      indentation: '  ',\n      filter: (node) => node.type !== 'Comment',\n      collapseContent: true,\n      lineSeparator: '\\n'\n    });\n  } catch (error) {\n    console.error('XML formatting error (library):', error);\n    return xmlString;\n  }\n}\n```\n\n**Advantages of xml-formatter library:**\n\n- **Robust parsing**: Better handling of edge cases and complex XML structures\n- **Advanced options**: Node filtering, configurable indentation, comment handling\n- **Performance**: Optimized for large XML documents\n- **Standardization**: Widely used library with consistent results\n- **Flexibility**: Ability to customize output format according to needs\n\nUsers have access to both options - basic formatting for quick use and advanced formatting for more complex XML documents.\n\n## Styling and UI/UX Design\n\n### CSS Architecture\n\nThe project utilizes BEM (Block Element Modifier) methodology for CSS organization:\n\n```css\n.xml-viewer-highlight {\n  background: #2C2C2C;\n  border-radius: 8px;\n  padding: 1.5rem;\n}\n\n.xml-viewer-highlight__header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.xml-viewer-highlight__copy-button {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.xml-viewer-highlight__copy-button--active {\n  background: #F7464E;\n  color: #F7F8F3;\n}\n```\n\nBEM provides clear naming conventions and prevents CSS conflicts. The modular approach enables easy maintenance and refactoring.\n\n### Dark Mode Theme\n\nThe application implements dark mode as the primary theme using CSS custom properties:\n\n```css\n:root {\n  --primary-bg: #1A1A1A;\n  --secondary-bg: #2C2C2C;\n  --card-bg: #333333;\n  --text-primary: #F7F8F3;\n  --text-secondary: #999;\n  --accent-teal: #78BCC4;\n  --accent-crimson: #F7464E;\n}\n\nbody {\n  background-color: var(--primary-bg);\n  color: var(--text-primary);\n}\n```\n\nCustom properties enable easy theme switching in the future and consistent color palette across the application.\n\n### Responsive Design\n\nImplementation of mobile-first approach with progressive enhancement:\n\n```css\n/* Mobile first */\n.viewer-controls__grid {\n  display: grid;\n  grid-template-columns: repeat(2, 1fr);\n  gap: 0.75rem;\n}\n\n/* Tablet */\n@media (min-width: 768px) {\n  .viewer-controls__grid {\n    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));\n    gap: 1rem;\n  }\n}\n\n/* Desktop */\n@media (min-width: 1024px) {\n  .viewer-controls__grid {\n    gap: 1.5rem;\n  }\n}\n```\n\nCSS Grid provides flexible layout with automatic flow for different screen sizes. Auto-fit and minmax ensure optimal use of available space.\n\n## Performance Optimization\n\n### Bundle Size Optimization\n\nSelective imports from libraries minimize bundle size:\n\n```javascript\n// Instead of entire library\nimport hljs from 'highlight.js';\n\n// Import only necessary parts\nimport hljs from 'highlight.js/lib/core';\nimport xml from 'highlight.js/lib/languages/xml';\n```\n\nThis approach reduces highlight.js bundle size from ~500KB to ~50KB.\n\n### Lazy Loading and Code Splitting\n\nInfrastructure for lazy loading is prepared for future application extensions:\n\n```javascript\n// Potential lazy loading for large XML viewers\nconst XmlViewerAdvanced = lazy(() => import('./XmlViewerAdvanced'));\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading...</div>}>\n      {showAdvanced && <XmlViewerAdvanced />}\n    </Suspense>\n  );\n}\n```\n\n### Memory Management\n\nProper cleanup for file readers and blob URLs:\n\n```javascript\nconst handleFileChange = (event) => {\n  const file = event.target.files[0];\n  if (file) {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      // Process file content\n      onFileLoad(e.target.result);\n    };\n    reader.onerror = (error) => {\n      console.error('File reading error:', error);\n    };\n    reader.readAsText(file);\n  }\n};\n```\n\nExplicit error handling for FileReader prevents memory leaks when reading large files.\n\n## Error Handling and Edge Cases\n\n### Graceful Error Handling\n\nThe application implements comprehensive error handling:\n\n```javascript\nconst [validationError, setValidationError] = useState(null);\n\nconst handleXmlChange = (content) => {\n  setXmlContent(content);\n  setValidationError(null);\n\n  if (content.trim()) {\n    const validation = validateXml(content);\n    if (!validation.isValid) {\n      setValidationError(validation.error);\n    }\n  }\n};\n```\n\nReal-time validation provides immediate feedback without requiring explicit submission.\n\n### Large File Handling\n\nFor large XML files, we implement progressive loading:\n\n```javascript\nconst handleLargeFile = (file) => {\n  if (file.size > 5 * 1024 * 1024) { // 5MB limit\n    alert('File is too large. Please use a smaller XML file.');\n    return;\n  }\n\n  // Process normally\n  processFile(file);\n};\n```\n\nSize limits prevent browser freeze when loading extremely large XML documents.\n\n### Cross-browser Compatibility\n\nThe application tests support for key APIs:\n\n```javascript\nconst checkBrowserSupport = () => {\n  if (!window.DOMParser) {\n    console.warn('DOMParser not supported');\n    return false;\n  }\n\n  if (!window.XMLSerializer) {\n    console.warn('XMLSerializer not supported');\n    return false;\n  }\n\n  return true;\n};\n```\n\n## Accessibility (A11Y) Implementation\n\n### Keyboard Navigation\n\nAll interactive elements support keyboard navigation:\n\n```css\n.viewer-controls__button:focus {\n  outline: 2px solid var(--accent-teal);\n  outline-offset: 2px;\n}\n\n.xml-input__textarea:focus {\n  border-color: var(--accent-teal);\n  box-shadow: 0 0 0 2px rgba(120, 188, 196, 0.2);\n}\n```\n\n### Screen Reader Support\n\nSemantic HTML and ARIA labels for screen readers:\n\n```jsx\n<button\n  className=\"xml-viewer-basic__copy-button\"\n  onClick={handleCopy}\n  aria-label=\"Copy XML content to clipboard\"\n  title=\"Copy to clipboard\"\n>\n  {copied ? 'Copied!' : 'Copy'}\n</button>\n```\n\n### Color Contrast\n\nAll color combinations meet WCAG 2.1 AA requirements with a contrast ratio of at least 4.5:1.\n\n## Testing Strategy\n\n### Unit Testing\n\nFor critical utility functions:\n\n```javascript\ndescribe('xmlUtils', () => {\n  test('validateXml returns true for valid XML', () => {\n    const validXml = '<?xml version=\"1.0\"?><root><child>content</child></root>';\n    const result = validateXml(validXml);\n    expect(result.isValid).toBe(true);\n  });\n\n  test('validateXml returns error for invalid XML', () => {\n    const invalidXml = '<root><child>unclosed';\n    const result = validateXml(invalidXml);\n    expect(result.isValid).toBe(false);\n    expect(result.error).toContain('error');\n  });\n});\n```\n\n### Integration Testing\n\nTesting user workflows with React Testing Library:\n\n```javascript\ntest('user can load sample XML and view it', async () => {\n  render(<App />);\n\n  const loadSampleButton = screen.getByText('Load Sample');\n  fireEvent.click(loadSampleButton);\n\n  const showBasicButton = screen.getByText('Show Basic');\n  fireEvent.click(showBasicButton);\n\n  expect(screen.getByText(/catalog/)).toBeInTheDocument();\n});\n```\n\n### E2E Testing\n\nCypress tests for complete user journeys:\n\n```javascript\ndescribe('XML Viewer E2E', () => {\n  it('should handle complete XML workflow', () => {\n    cy.visit('/');\n    cy.get('[data-testid=\"load-sample\"]').click();\n    cy.get('[data-testid=\"open-new-tab\"]').click();\n    cy.get('[data-testid=\"show-highlighted\"]').click();\n    cy.get('.xml-viewer-highlight').should('be.visible');\n  });\n});\n```\n\n## Security Considerations\n\n### XSS Prevention\n\nAll user input is properly sanitized:\n\n```javascript\nconst sanitizeXml = (xmlString) => {\n  // Remove potential script tags and dangerous content\n  return xmlString.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '');\n};\n```\n\n### File Upload Security\n\nValidation of file types and size limits:\n\n```javascript\nconst isValidXmlFile = (file) => {\n  const allowedTypes = ['text/xml', 'application/xml'];\n  const allowedExtensions = ['.xml'];\n\n  return allowedTypes.includes(file.type) ||\n         allowedExtensions.some(ext => file.name.toLowerCase().endsWith(ext));\n};\n```\n\n### CSP Headers\n\nContent Security Policy for production deployment:\n\n```\nContent-Security-Policy: default-src 'self';\nscript-src 'self' 'unsafe-inline';\nstyle-src 'self' 'unsafe-inline';\nimg-src 'self' data: blob:;\n```\n\n## Production Deployment\n\n### Build Optimization\n\nVite build optimization for production:\n\n```javascript\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          vendor: ['react', 'react-dom'],\n          highlight: ['highlight.js']\n        }\n      }\n    }\n  }\n});\n```\n\n### Progressive Web App Features\n\nService Worker for offline support:\n\n```javascript\n// Future implementation\nconst CACHE_NAME = 'xml-viewer-v1';\nconst urlsToCache = [\n  '/',\n  '/static/js/bundle.js',\n  '/static/css/main.css'\n];\n\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) => cache.addAll(urlsToCache))\n  );\n});\n```\n\n## Future Extensions\n\n### Planned Features\n\n1. **XML Schema Validation**: XSD validation implementation\n2. **XSLT Transformation**: Support for XML transformations\n3. **Diff Viewer**: Comparison of two XML documents\n4. **XML to JSON Converter**: Bidirectional conversion\n5. **Collaborative Editing**: Real-time collaboration\n6. **Cloud Storage Integration**: Google Drive, Dropbox sync\n\n### Technology Improvements\n\n1. **TypeScript Migration**: Type safety and better DX\n2. **React 19 Concurrent Features**: Server Components\n3. **WebAssembly Integration**: Faster XML parsing\n4. **IndexedDB Storage**: Offline XML library\n5. **Web Workers**: Background XML processing\n\n## Conclusion\n\nXML Viewer SPA represents a modern approach to working with XML documents in web environments. The application successfully combines ease of use with advanced features and demonstrates best practices for React applications in 2024.\n\nKey project successes:\n\n1. **User Experience**: Intuitive interface with immediate feedback\n2. **Performance**: Optimized bundle size and fast loading\n3. **Accessibility**: WCAG 2.1 compliance and keyboard navigation\n4. **Maintainability**: Clean architecture with clear separation of concerns\n5. **Extensibility**: Modular design ready for future extensions\n\nThe project demonstrates how modern web technologies enable the creation of robust applications for specialized use cases like XML processing. The combination of React 18, Vite, highlight.js, and xml-formatter provides a solid foundation for complex XML workflows.\n\nFor developers interested in similar projects, we recommend focusing on proper error handling, accessibility, and performance optimization from the beginning of development. These aspects are often underestimated but critical for production-ready applications.\n\nComplete source code is available on GitHub with MIT license, enabling free usage for commercial projects. We welcome community contributions and feedback for further improvements.\n\n---\n\nAuthor: David Hezký\nDate: September 2025\nTechnologies: React 18, Vite, Highlight.js, XML-formatter\nLicense: MIT*"
}